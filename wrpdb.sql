/*
Navicat MySQL Data Transfer

Source Server         : localhost2
Source Server Version : 50553
Source Host           : localhost:3306
Source Database       : wrpdb

Target Server Type    : MYSQL
Target Server Version : 50553
File Encoding         : 65001

Date: 2017-07-15 10:00:22
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for te_about
-- ----------------------------
DROP TABLE IF EXISTS `te_about`;
CREATE TABLE `te_about` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '关于我们ID',
  `content` text NOT NULL COMMENT '关于我们内容',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of te_about
-- ----------------------------
INSERT INTO `te_about` VALUES ('1', 'ThinkPHP 是一个免费开源的，快速、简单的面向对象的 轻量级PHP开发框架 ，创立于2006年初，遵循Apache2开源协议发布，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。ThinkPHP从诞生以来一直秉承简洁实用的设计原则，在保持出色的性能和至简的代码的同时，也注重易用性。并且拥有众多的原创功能和特性，在社区团队的积极参与下，在易用性、扩展性和性能方面不断优化和改进，已经成长为国内最领先和最具影响力的WEB应用开发框架，众多的典型案例确保可以稳定用于商业以及门户级的开发。');

-- ----------------------------
-- Table structure for te_article
-- ----------------------------
DROP TABLE IF EXISTS `te_article`;
CREATE TABLE `te_article` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '文章ID',
  `title` varchar(32) NOT NULL COMMENT '文章标题',
  `content` text NOT NULL COMMENT '文章内容',
  `f_id` int(10) NOT NULL COMMENT '外键ID',
  `create_time` date NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=47 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of te_article
-- ----------------------------
INSERT INTO `te_article` VALUES ('26', 'Linux常用命令大全', '系统信息 \r\n\r\narch 显示机器的处理器架构(1) \r\n\r\nuname -m 显示机器的处理器架构(2) \r\n\r\nuname -r 显示正在使用的内核版本 \r\n\r\ndmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) \r\n\r\nhdparm -i /dev/hda 罗列一个磁盘的架构特性 \r\n\r\nhdparm -tT /dev/sda 在磁盘上执行测试性读取操作 \r\n\r\ncat /proc/cpuinfo 显示CPU info的信息 \r\n\r\ncat /proc/interrupts 显示中断 \r\n\r\ncat /proc/meminfo 校验内存使用 \r\n\r\ncat /proc/swaps 显示哪些swap被使用 \r\n\r\ncat /proc/version 显示内核的版本 \r\n\r\ncat /proc/net/dev 显示网络适配器及统计 \r\n\r\ncat /proc/mounts 显示已加载的文件系统 \r\n\r\nlspci -tv 罗列 PCI 设备 \r\n\r\nlsusb -tv 显示 USB 设备 \r\n\r\ndate 显示系统日期 \r\n\r\ncal 2007 显示2007年的日历表 \r\n\r\ndate 041217002007.00 设置日期和时间 - 月日时分年.秒 \r\n\r\nclock -w 将时间修改保存到 BIOS \r\n\r\n\r\n\r\n\r\n关机 (系统的关机、重启以及登出 ) \r\n\r\nshutdown -h now 关闭系统(1) \r\n\r\ninit 0 关闭系统(2) \r\n\r\ntelinit 0 关闭系统(3) \r\n\r\nshutdown -h hours:minutes &amp; 按预定时间关闭系统 \r\n\r\nshutdown -c 取消按预定时间关闭系统 \r\n\r\nshutdown -r now 重启(1) \r\n\r\nreboot 重启(2) \r\n\r\nlogout 注销 \r\n\r\n\r\n\r\n\r\n文件和目录 \r\n\r\ncd /home 进入 \'/ home\' 目录\' \r\n\r\ncd .. 返回上一级目录 \r\n\r\ncd ../.. 返回上两级目录 \r\n\r\ncd 进入个人的主目录 \r\n\r\ncd ~user1 进入个人的主目录 \r\n\r\ncd - 返回上次所在的目录 \r\n\r\npwd 显示工作路径 \r\n\r\nls 查看目录中的文件 \r\n\r\nls -F 查看目录中的文件 \r\n\r\nls -l 显示文件和目录的详细资料 \r\n\r\nls -a 显示隐藏文件 \r\n\r\nls *[0-9]* 显示包含数字的文件名和目录名 \r\n\r\ntree 显示文件和目录由根目录开始的树形结构(1) \r\n\r\nlstree 显示文件和目录由根目录开始的树形结构(2) \r\n\r\nmkdir dir1 创建一个叫做 \'dir1\' 的目录\' \r\n\r\nmkdir dir1 dir2 同时创建两个目录 \r\n\r\nmkdir -p /tmp/dir1/dir2 创建一个目录树 \r\n\r\nrm -f file1 删除一个叫做 \'file1\' 的文件\' \r\n\r\nrmdir dir1 删除一个叫做 \'dir1\' 的目录\' \r\n\r\nrm -rf dir1 删除一个叫做 \'dir1\' 的目录并同时删除其内容 \r\n\r\nrm -rf dir1 dir2 同时删除两个目录及它们的内容 \r\n\r\nmv dir1 new_dir 重命名/移动 一个目录 \r\n\r\ncp file1 file2 复制一个文件 \r\n\r\ncp dir/* . 复制一个目录下的所有文件到当前工作目录 \r\n\r\ncp -a /tmp/dir1 . 复制一个目录到当前工作目录 \r\n\r\ncp -a dir1 dir2 复制一个目录 \r\n\r\nln -s file1 lnk1 创建一个指向文件或目录的软链接 \r\n\r\nln file1 lnk1 创建一个指向文件或目录的物理链接 \r\n\r\ntouch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) \r\n\r\nfile file1 outputs the mime type of the file as text \r\n\r\niconv -l 列出已知的编码 \r\n\r\niconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. \r\n\r\nfind . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; \\; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) \r\n\r\n\r\n\r\n\r\n文件搜索 \r\n\r\nfind / -name file1 从 \'/\' 开始进入根文件系统搜索文件和目录 \r\n\r\nfind / -user user1 搜索属于用户 \'user1\' 的文件和目录 \r\n\r\nfind /home/user1 -name \\*.bin 在目录 \'/ home/user1\' 中搜索带有\'.bin\' 结尾的文件 \r\n\r\nfind /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 \r\n\r\nfind /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 \r\n\r\nfind / -name \\*.rpm -exec chmod 755 \'{}\' \\; 搜索以 \'.rpm\' 结尾的文件并定义其权限 \r\n\r\nfind / -xdev -name \\*.rpm 搜索以 \'.rpm\' 结尾的文件，忽略光驱、捷盘等可移动设备 \r\n\r\nlocate \\*.ps 寻找以 \'.ps\' 结尾的文件 - 先运行 \'updatedb\' 命令 \r\n\r\nwhereis halt 显示一个二进制文件、源码或man的位置 \r\n\r\nwhich halt 显示一个二进制文件或可执行文件的完整路径 \r\n\r\n\r\n\r\n\r\n挂载一个文件系统 \r\n\r\nmount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 \'/ mnt/hda2\' 已经存在 \r\n\r\numount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 \'/ mnt/hda2\' 退出 \r\n\r\nfuser -km /mnt/hda2 当设备繁忙时强制卸载 \r\n\r\numount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 \r\n\r\nmount /dev/fd0 /mnt/floppy 挂载一个软盘 \r\n\r\nmount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom \r\n\r\nmount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom \r\n\r\nmount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom \r\n\r\nmount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 \r\n\r\nmount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 \r\n\r\nmount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 \r\n\r\nmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 \r\n\r\n\r\n\r\n\r\n磁盘空间 \r\n\r\ndf -h 显示已经挂载的分区列表 \r\n\r\nls -lSr |more 以尺寸大小排列文件和目录 \r\n\r\ndu -sh dir1 估算目录 \'dir1\' 已经使用的磁盘空间\' \r\n\r\ndu -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 \r\n\r\nrpm -q -a --qf \'%10{SIZE}t%{NAME}n\' | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) \r\n\r\ndpkg-query -W -f=\'${Installed-Size;10}t${Package}n\' | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n用户和群组 \r\n\r\ngroupadd group_name 创建一个新用户组 \r\n\r\ngroupdel group_name 删除一个用户组 \r\n\r\ngroupmod -n new_group_name old_group_name 重命名一个用户组 \r\n\r\nuseradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 \r\n\r\nuseradd user1 创建一个新用户 \r\n\r\nuserdel -r user1 删除一个用户 ( \'-r\' 排除主目录) \r\n\r\nusermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 \r\n\r\npasswd 修改口令 \r\n\r\npasswd user1 修改一个用户的口令 (只允许root执行) \r\n\r\nchage -E 2005-12-31 user1 设置用户口令的失效期限 \r\n\r\npwck 检查 \'/etc/passwd\' 的文件格式和语法修正以及存在的用户 \r\n\r\ngrpck 检查 \'/etc/passwd\' 的文件格式和语法修正以及存在的群组 \r\n\r\nnewgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n文件的权限 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 \r\n\r\nls -lh 显示权限 \r\n\r\nls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 \r\n\r\nchmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 \r\n\r\nchmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 \r\n\r\nchown user1 file1 改变一个文件的所有人属性 \r\n\r\nchown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 \r\n\r\nchgrp group1 file1 改变文件的群组 \r\n\r\nchown user1:group1 file1 改变一个文件的所有人和群组属性 \r\n\r\nfind / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 \r\n\r\nchmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 \r\n\r\nchmod u-s /bin/file1 禁用一个二进制文件的 SUID位 \r\n\r\nchmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 \r\n\r\nchmod g-s /home/public 禁用一个目录的 SGID 位 \r\n\r\nchmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 \r\n\r\nchmod o-t /home/public 禁用一个目录的 STIKY 位 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n文件的特殊属性 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 \r\n\r\nchattr +a file1 只允许以追加方式读写文件 \r\n\r\nchattr +c file1 允许这个文件能被内核自动压缩/解压 \r\n\r\nchattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 \r\n\r\nchattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 \r\n\r\nchattr +s file1 允许一个文件被安全地删除 \r\n\r\nchattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 \r\n\r\nchattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 \r\n\r\nlsattr 显示特殊的属性 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n打包和压缩文件 \r\n\r\nbunzip2 file1.bz2 解压一个叫做 \'file1.bz2\'的文件 \r\n\r\nbzip2 file1 压缩一个叫做 \'file1\' 的文件 \r\n\r\ngunzip file1.gz 解压一个叫做 \'file1.gz\'的文件 \r\n\r\ngzip file1 压缩一个叫做 \'file1\'的文件 \r\n\r\ngzip -9 file1 最大程度压缩 \r\n\r\nrar a file1.rar test_file 创建一个叫做 \'file1.rar\' 的包 \r\n\r\nrar a file1.rar file1 file2 dir1 同时压缩 \'file1\', \'file2\' 以及目录 \'dir1\' \r\n\r\nrar x file1.rar 解压rar包 \r\n\r\nunrar x file1.rar 解压rar包 \r\n\r\ntar -cvf archive.tar file1 创建一个非压缩的 tarball \r\n\r\ntar -cvf archive.tar file1 file2 dir1 创建一个包含了 \'file1\', \'file2\' 以及 \'dir1\'的档案文件 \r\n\r\ntar -tf archive.tar 显示一个包中的内容 \r\n\r\ntar -xvf archive.tar 释放一个包 \r\n\r\ntar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 \r\n\r\ntar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 \r\n\r\ntar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 \r\n\r\ntar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 \r\n\r\ntar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 \r\n\r\nzip file1.zip file1 创建一个zip格式的压缩包 \r\n\r\nzip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \r\n\r\nunzip file1.zip 解压一个zip格式压缩包 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\nRPM 包 - （Fedora, Redhat及类似系统） \r\n\r\nrpm -ivh package.rpm 安装一个rpm包 \r\n\r\nrpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 \r\n\r\nrpm -U package.rpm 更新一个rpm包但不改变其配置文件 \r\n\r\nrpm -F package.rpm 更新一个确定已经安装的rpm包 \r\n\r\nrpm -e package_name.rpm 删除一个rpm包 \r\n\r\nrpm -qa 显示系统中所有已经安装的rpm包 \r\n\r\nrpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 \r\n\r\nrpm -qi package_name 获取一个已安装包的特殊信息 \r\n\r\nrpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包 \r\n\r\nrpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 \r\n\r\nrpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 \r\n\r\nrpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 \r\n\r\nrpm -q package_name --whatprovides 显示一个rpm包所占的体积 \r\n\r\nrpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l \r\n\r\nrpm -q package_name --changelog 显示一个rpm包的修改历史 \r\n\r\nrpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 \r\n\r\nrpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 \r\n\r\nrpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 \r\n\r\nrpm --checksig package.rpm 确认一个rpm包的完整性 \r\n\r\nrpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 \r\n\r\nrpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 \r\n\r\nrpm -Va 检查系统中所有已安装的rpm包- 小心使用 \r\n\r\nrpm -Vp package.rpm 确认一个rpm包还未安装 \r\n\r\nrpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 \r\n\r\nrpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 \r\n\r\nrpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\nYUM 软件包升级器 - （Fedora, RedHat及类似系统） \r\n\r\nyum install package_name 下载并安装一个rpm包 \r\n\r\nyum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 \r\n\r\nyum update package_name.rpm 更新当前系统中所有安装的rpm包 \r\n\r\nyum update package_name 更新一个rpm包 \r\n\r\nyum remove package_name 删除一个rpm包 \r\n\r\nyum list 列出当前系统中安装的所有包 \r\n\r\nyum search package_name 在rpm仓库中搜寻软件包 \r\n\r\nyum clean packages 清理rpm缓存删除下载的包 \r\n\r\nyum clean headers 删除所有头文件 \r\n\r\nyum clean all 删除所有缓存的包和头文件 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\nDEB 包 (Debian, Ubuntu 以及类似系统) \r\n\r\ndpkg -i package.deb 安装/更新一个 deb 包 \r\n\r\ndpkg -r package_name 从系统删除一个 deb 包 \r\n\r\ndpkg -l 显示系统中所有已经安装的 deb 包 \r\n\r\ndpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 \r\n\r\ndpkg -s package_name 获得已经安装在系统中一个特殊包的信息 \r\n\r\ndpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 \r\n\r\ndpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 \r\n\r\ndpkg -S /bin/ping 确认所给的文件由哪个deb包提供 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\nAPT 软件工具 (Debian, Ubuntu 以及类似系统) \r\n\r\napt-get install package_name 安装/更新一个 deb 包 \r\n\r\napt-cdrom install package_name 从光盘安装/更新一个 deb 包 \r\n\r\napt-get update 升级列表中的软件包 \r\n\r\napt-get upgrade 升级所有已安装的软件 \r\n\r\napt-get remove package_name 从系统删除一个deb包 \r\n\r\napt-get check 确认依赖的软件仓库正确 \r\n\r\napt-get clean 从下载的软件包中清理缓存 \r\n\r\napt-cache search searched-package 返回包含所要搜索字符串的软件包名称 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n查看文件内容 \r\n\r\ncat file1 从第一个字节开始正向查看文件的内容 \r\n\r\ntac file1 从最后一行开始反向查看一个文件的内容 \r\n\r\nmore file1 查看一个长文件的内容 \r\n\r\nless file1 类似于 \'more\' 命令，但是它允许在文件中和正向操作一样的反向操作 \r\n\r\nhead -2 file1 查看一个文件的前两行 \r\n\r\ntail -2 file1 查看一个文件的最后两行 \r\n\r\ntail -f /var/log/messages 实时查看被添加到一个文件中的内容 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n文本处理 \r\n\r\ncat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT \r\n\r\ncat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 \r\n\r\ncat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 \r\n\r\ngrep Aug /var/log/messages 在文件 \'/var/log/messages\'中查找关键词&quot;Aug&quot; \r\n\r\ngrep ^Aug /var/log/messages 在文件 \'/var/log/messages\'中查找以&quot;Aug&quot;开始的词汇 \r\n\r\ngrep [0-9] /var/log/messages 选择 \'/var/log/messages\' 文件中所有包含数字的行 \r\n\r\ngrep Aug -R /var/log/* 在目录 \'/var/log\' 及随后的目录中搜索字符串&quot;Aug&quot; \r\n\r\nsed \'s/stringa1/stringa2/g\' example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; \r\n\r\nsed \'/^$/d\' example.txt 从example.txt文件中删除所有空白行 \r\n\r\nsed \'/ *#/d; /^$/d\' example.txt 从example.txt文件中删除所有注释和空白行 \r\n\r\necho \'esempio\' | tr \'[:lower:]\' \'[:upper:]\' 合并上下单元格内容 \r\n\r\nsed -e \'1d\' result.txt 从文件example.txt 中排除第一行 \r\n\r\nsed -n \'/stringa1/p\' 查看只包含词汇 &quot;string1&quot;的行 \r\n\r\nsed -e \'s/ *$//\' example.txt 删除每一行最后的空白字符 \r\n\r\nsed -e \'s/stringa1//g\' example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 \r\n\r\nsed -n \'1,5p;5q\' example.txt 查看从第一行到第5行内容 \r\n\r\nsed -n \'5p;5q\' example.txt 查看第5行 \r\n\r\nsed -e \'s/00*/0/g\' example.txt 用单个零替换多个零 \r\n\r\ncat -n file1 标示文件的行数 \r\n\r\ncat example.txt | awk \'NR%2==1\' 删除example.txt文件中的所有偶数行 \r\n\r\necho a b c | awk \'{print $1}\' 查看一行第一栏 \r\n\r\necho a b c | awk \'{print $1,$3}\' 查看一行的第一和第三栏 \r\n\r\npaste file1 file2 合并两个文件或两栏的内容 \r\n\r\npaste -d \'+\' file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 \r\n\r\nsort file1 file2 排序两个文件的内容 \r\n\r\nsort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) \r\n\r\nsort file1 file2 | uniq -u 删除交集，留下其他的行 \r\n\r\nsort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) \r\n\r\ncomm -1 file1 file2 比较两个文件的内容只删除 \'file1\' 所包含的内容 \r\n\r\ncomm -2 file1 file2 比较两个文件的内容只删除 \'file2\' 所包含的内容 \r\n\r\ncomm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n\r\n字符设置和文件格式转换 \r\n\r\ndos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX \r\n\r\nunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS \r\n\r\nrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html \r\n\r\nrecode -l | more 显示所有允许的转换格式 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n文件系统分析 \r\n\r\nbadblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 \r\n\r\nfsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 \r\n\r\nfsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 \r\n\r\ne2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 \r\n\r\ne2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 \r\n\r\nfsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 \r\n\r\nfsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 \r\n\r\nfsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 \r\n\r\ndosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n初始化一个文件系统 \r\n\r\nmkfs /dev/hda1 在hda1分区创建一个文件系统 \r\n\r\nmke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 \r\n\r\nmke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 \r\n\r\nmkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 \r\n\r\nfdformat -n /dev/fd0 格式化一个软盘 \r\n\r\nmkswap /dev/hda3 创建一个swap文件系统 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\nSWAP文件系统 \r\n\r\nmkswap /dev/hda3 创建一个swap文件系统 \r\n\r\nswapon /dev/hda3 启用一个新的swap文件系统 \r\n\r\nswapon /dev/hda2 /dev/hdb3 启用两个swap分区 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n备份 \r\n\r\ndump -0aj -f /tmp/home0.bak /home 制作一个 \'/home\' 目录的完整备份 \r\n\r\ndump -1aj -f /tmp/home0.bak /home 制作一个 \'/home\' 目录的交互式备份 \r\n\r\nrestore -if /tmp/home0.bak 还原一个交互式备份 \r\n\r\nrsync -rogpav --delete /home /tmp 同步两边的目录 \r\n\r\nrsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync \r\n\r\nrsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 \r\n\r\nrsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 \r\n\r\ndd bs=1M if=/dev/hda | gzip | ssh user@ip_addr \'dd of=hda.gz\' 通过ssh在远程主机上执行一次备份本地磁盘的操作 \r\n\r\ndd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 \r\n\r\ntar -Puf backup.tar /home/user 执行一次对 \'/home/user\' 目录的交互式备份操作 \r\n\r\n( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr \'cd /home/share/ &amp;&amp; tar x -p\' 通过ssh在远程目录中复制一个目录内容 \r\n\r\n( tar c /home ) | ssh -C user@ip_addr \'cd /home/backup-home &amp;&amp; tar x -p\' 通过ssh在远程目录中复制一个本地目录 \r\n\r\ntar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 \r\n\r\nfind /home/user1 -name \'*.txt\' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 \'.txt\' 结尾的文件到另一个目录 \r\n\r\nfind /var/log -name \'*.log\' | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 \'.log\' 结尾的文件并做成一个bzip包 \r\n\r\ndd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 \r\n\r\ndd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n光盘 \r\n\r\ncdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 \r\n\r\nmkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 \r\n\r\nmkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 \r\n\r\nmkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 \r\n\r\ncdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 \r\n\r\ngzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 \r\n\r\nmount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 \r\n\r\ncd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 \r\n\r\ncd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） \r\n\r\ncdrecord --scanbus 扫描总线以识别scsi通道 \r\n\r\ndd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD \r\n\r\n\r\n返回顶部索引 ^\r\n\r\n\r\n网络 - （以太网和WIFI无线） \r\n\r\nifconfig eth0 显示一个以太网卡的配置 \r\n\r\nifup eth0 启用一个 \'eth0\' 网络设备 \r\n\r\nifdown eth0 禁用一个 \'eth0\' 网络设备 \r\n\r\nifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 \r\n\r\nifconfig eth0 promisc 设置 \'eth0\' 成混杂模式以嗅探数据包 (sniffing) \r\n\r\ndhclient eth0 以dhcp模式启用 \'eth0\' \r\n\r\nroute -n show routing table \r\n\r\nroute add -net 0/0 gw IP_Gateway configura default gateway \r\n\r\nroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network \'192.168.0.0/16\' \r\n\r\nroute del 0/0 gw IP_gateway remove static route \r\n\r\necho &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing \r\n\r\nhostname show hostname of system \r\n\r\nhost www.example.com lookup hostname to resolve name to ip address and viceversa(1) \r\n\r\nnslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) \r\n\r\nip link show show link status of all interfaces \r\n\r\nmii-tool eth0 show link status of \'eth0\' \r\n\r\nethtool eth0 show statistics of network card \'eth0\' \r\n\r\nnetstat -tup show all active network connections and their PID \r\n\r\nnetstat -tupl show all network services listening on the system and their PID \r\n\r\ntcpdump tcp port 80 show all HTTP traffic \r\n\r\niwlist scan show wireless networks \r\n\r\niwconfig eth1 show configuration of a wireless network card \r\n\r\nhostname show hostname \r\n\r\nhost www.example.com lookup hostname to resolve name to ip address and viceversa \r\n\r\nnslookup www.example.com lookup hostname to resolve name to ip address and viceversa \r\n\r\nwhois www.example.com lookup on Whois database \r\n\r\n\r\nGO TOP INDEX ^ \r\n\r\nMicrosoft Windows networks (SAMBA) \r\n\r\nnbtscan ip_addr netbios name resolution \r\n\r\nnmblookup -A ip_addr netbios name resolution \r\n\r\nsmbclient -L ip_addr/hostname show remote shares of a windows host \r\n\r\nsmbget -Rr smb://ip_addr/share like wget can download files from a host windows via smb \r\n\r\nmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('15', 'web页面如何打包封闭成手机APP', '所谓的webApp就是html页面跟原生app结合而成的一种应用，这种应用的开发可以节省不少的成本，做出来的app跟原生一样，webApp利用框架技术可以让你有使用app的感觉，具体可以看平安银行的app\r\n工具/原料\r\n  ● 电脑\r\n  ● eclipse，git，nodejs，jdk，cordova\r\n  ● 一个完整的手机网站\r\n方法/步骤\r\n  1. 1\r\n首页得准备好需要的东西，如eclipse，一个完整可以浏览的手机网站，而且确保电脑配置好jdk，环境变量，还要安装好cordova，这些环境等配置这里不表，可以自行百度。在这里我就自己随意写了个网站做测试，从下图可以看出来，这是一个可以在网页中浏览的手机网站\r\n\r\n  2. 2\r\n有了网站之后，第一步新建一个项目，打开你要保存的项目地址，比如D盘的yun文件夹，按住键盘的shift键+鼠标右键，选择“在此处打开命令窗口”，就会弹出一个终端命令窗口，打开之后在终端里面输入cordova create hello，hello为你的项目名称，如cordova create qianqian，qianqian就是我的项目名称，注意，不要手动去创建文件夹，因为我们在终端里面建的项目里面有很多的配置文件，终端命令窗口不要关\r\n\r\n\r\n  3. 3\r\n在终端命令窗口中输入cd qianqian，进入qianqian文件夹，然后再输入cordova platform add android，回车，等待下载完成，记住在下载之前一定要确保已经安装git，要不然会下载失败，本人亲自试验，下载可以要1分钟左右，下载完成后终端命令窗口不要关，等下要用\r\n\r\n  4. 4\r\n下载完成后将准备好的网站放到www文件夹里面，原来的文件可以删掉，再打开eclipse软件，点击菜单栏file--import，弹出一个窗口，选择下面图片中的选项，再点next，之后点击Browse，选择qianqian文件夹项目的路径，选取，记住，复选框一定要全部选上，不懂的看下面的图片，然后确定就可以了\r\n\r\n\r\n  5. 5\r\n确定之后就会看到下面图片一样左边会出现两个项目，为了确保项目一次性完成，我们可以在终端窗口里面输入cordova prepare，输入前确保是在当前qianqian文件夹，这个命令是在修改过项目的情况下运行的，等待他运行完，下面第二张图片是运行完成的图片\r\n\r\n\r\n  6. 6\r\nok，之后就可以打包webapp了，回到eclipse，我们发现项目文件有个红叉，或者也会出现一个感叹号之类的，出现这个情况的话可以点击菜单栏project--clean，在弹出的窗口中选择第二个单选项，下面的复选框全部选上，不懂看图，确认之后就可以看到红叉没了\r\n\r\n  7. 7\r\n然后在项目栏里选择第二个项目右键选择run as--android application，之后等待半分钟左右，主要是看电脑运行速度好不好了，好的话就快\r\n\r\n  8. 8\r\n最后如果你手机连接着电脑或者你电脑开着安卓虚拟机的话，在弹出的窗口就会出现你手机或者虚拟机的信息，选择他再点ok，系统会自动跳到虚拟机里，如果是真机的话，就直接看你的手机就行，手机会自动安装app应用的\r\n\r\n  9. 9\r\n如果两者都没有的话可以将弹出的窗口都关闭，然后在软件项目栏的第二个项目里面有个bin文件夹，打开，里面有个apk，将他复制出来安装到自己手机或其他机器里就行了，下图就是webapp做出来的最终效果，一开始忘记上传图片，只上传了代码，所以app里面没有图片，不过效果总算是出来了\r\n\r\n\r\nEND', '47', '2017-05-19');
INSERT INTO `te_article` VALUES ('22', 'HTML_head标签中META,IF IE 及 IFrame ', 'meta中常用的标签：\r\n‍&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;!-- 设置页面编码 --&gt;\r\n&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot; /&gt;&lt;!--设置页面语言 --&gt;\r\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE7&quot; /&gt;&lt;!-- 强制使用IE7模式渲染 --&gt;\r\n&lt;!-- 在IE使用时，强制使用当前IE浏览器的最新版本模式渲染，在非ＩＥ使用时，强制使用Chrome的模式渲染 --&gt;\r\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,Chrome=1&quot; /&gt;\r\n&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;&lt;!-- Baidu:禁止百度生成转码后的手机站 --&gt;\r\n&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5;URL=http://www.baidu.com&quot; /&gt;&lt;!-- 5秒后自动刷新指向新页面 --&gt;\r\n&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;&lt;!-- 禁止浏览器从本地计算机的缓存中访问页面内容 --&gt;\r\n&lt;meta name=&quot;keywords&quot; content=&quot;keywords01,keywords02&quot;&gt;&lt;!-- 向搜索引擎说明你的网页的关键词 --&gt;\r\n&lt;meta name=&quot;description&quot; content=&quot;this is my web description.&quot;&gt;&lt;!-- 告诉搜索引擎你的站点的主要内容 --&gt;\r\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot; /&gt;\r\n&lt;!--Mobile:默认设备宽度,初始大小1,最大尺寸1,禁止缩放 --&gt; \r\n&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt;&lt;!-- 360:默认采用高速模式 --&gt;\r\n IE 版本识别：\r\n&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;\r\n&lt;!--[if !IE]&gt; 除IE外都可识别 &lt;![endif]--&gt; \r\n&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt; \r\n&lt;!--[if lt IE 9]&gt; IE9以下版本可识别 &lt;![endif]--&gt; \r\n&lt;!--[if gt IE 6]&gt; IE6以上版本可识别 &lt;![endif]--&gt; \r\n&lt;!--[if lte IE 8]&gt; IE8及IE8以下版本可识别 &lt;![endif]--&gt; \r\n&lt;!--[if gte IE 9]&gt; IE9及IE9以上版本可识别 &lt;![endif]--&gt;\r\n \r\nIFrame渲染模式:\r\nIFrame是直接使用被嵌入的网页的渲染模式，不受IFrame里的强制渲染模式所控制。\r\neg:\r\nA网页通过Iframe嵌入了B网页，A网页使用了 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE7&quot; /&gt;,B网页使用了&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE10&quot; /&gt;,实际运行时，A，B网页都使用的IE7的模式进行渲染。', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('16', '你从画里来', '秋风萧萧渐去，颤抖了残枝落叶，萧瑟了前一季的三千繁华。寻不见，失踪在泥土深处，只剩一片片落叶，如残花败柳，悲凉了热情似火。当寒风凛冽，静止了画面，任风雪瑟瑟，竟独自惆怅。似花似美似画，是春是夏是年华。皑皑雪白的世界，除却记忆里的花花绿绿，只剩一声轻叹与黑发。记忆里，你的美，在一点点破碎，回不去的繁华，静悄悄的抽泣，模糊了你着色的山水画，徒留下回忆在等待白雪融化。\r\n　　上一季，你的容颜这般美丽，叙述的可不止片刻的风景，而是这无尽的眷恋。风景如画里，有一支，你未曾喜爱的曲子，悠扬婉转就在那里，弹奏出来的是一段凄美的故事，凄凄惨惨，音符散不去泪水。\r\n　　你在春风里，嫩绿色的柔美，仿佛，惊醒了整个大地。花开三月里，是你浓妆粉黛的美，如此，惊艳了整个森林。浅寻阳光下，重叠你的影子，在柔风中，在花香里，就此交融在一起，这只是缠绵的开始。\r\n　　夏日来临，舒展了身姿，似有深情，在梦里。繁花不在，花香依旧，寻不见的枝头，一片绿油油。风的来临，摇曳了你的世界，风飘万里，蔚然不动，得不到的安稳，飘摇了多少绿叶。狂风未散，磅礴大雨，折了岂止一枝头，击碎了最后一片叶，湿润了发梢，稀稀落落几滴雨，是睫毛闪动下的泪。盛夏雨季，刮不完的风，下不尽的雨，我看你飘摇在风雨里，摇摇欲坠，你的故事里，风和雨不应该是结局，留下来的，应是风雨后的美丽。\r\n　　抬头看去，晚霞相辉映，天地一色竟也如此美丽。几片落叶，飘飘随风飞舞，去一个，你从没去过的地方。几缕斜阳，熙攘了深秋里的忧伤。总会离去，枯叶泛黄之后只剩离别，终会再见，泥土芬芳了整个季节。等到春天里，又是一番花花绿绿。\r\n　　忽一场雪，就这么飘飘而来，惊扰了你秋日里的安静。再不见，昨日萧萧落叶里，埋藏了的回忆。花花世界消失去，剩下的只是一片白茫茫。逝去的时光中，任秋风落叶，或是白雪飘飘冬日里，我都记得，你曾经的美丽。笑靥如花，凭空多出来几许欢喜，或许，这就是我留恋的风景，悄悄的爱上了你。在三尺寒雪里，弹一曲，你没听过的旋律，为你，音符律动变成了美丽。\r\n　　在诗人的梦里，总有这么一些仙境，而你，正在这里。春来秋去，夏雨带着风雪来，在诗人的眼里，寒冬腊月独自在徘徊，却是春日里离开，夏日夜晚里凋残。平仄间，押韵里，满是柔情似水的眷恋，却忘了，这纸上，黑色的墨迹早已打湿在诗人的眼泪里。提笔写不出唯美爱恋，大笔一挥，满是凋零的韶华。低声吟不了柔美诗句，高歌一曲，尽是悲悯的相思。删删减减，涂写了多少岁月，揉碎多少个日夜，最凄凉，全在纸上。把你写进了开头，却写不出诗的结尾。零零散散，记忆里的笑容，这一刻，这么近，那么远。朝朝暮暮，憧憬许久的结局，这一刹，半思量，半悲伤。\r\n　　若是人生如戏，你就是那故事的主角，温婉尔雅，映衬了整个剧情。若只在戏里有，我宁愿这是一场演不完的故事，平平淡淡，牵手就是整个世界。无字的剧本，翻开全是你的身影，写下属于你的文字，连起来，就是整个故事。无声的对白，某一个眼神过往，感动的不止一个明天。下一场，我自远方来，走到你身前，伸出手，你微微颤动，我欣喜不已。在戏里，你挽着我走来幸福了几个春秋，一抬头，一双眼，感动了我们的以后。在戏外，你转身离开带走了多少喝彩，一停留，一回眸，静止了时间的流动。半戏半人生，跌宕间，顷刻犹豫便破碎了整个完美的画面。若有重来，写不完的故事，没有结局。\r\n　　还记得，那繁华后的宁静傍晚，安静了初见的精彩。还记得，那幽雅的繁花深处，惊扰了午后小憩的长椅。还记得，那一回眸的微微一笑，惊艳了闲庭信步的少年。还记得，那从天上来的银铃婉转，模糊了擦不掉的从前。还记得，那一眼万年的翘首以待，喧嚣了多少个宁静的夜晚。还记得，那条并肩走过的长亭古道，留下了多少唯美的画面。还记得，那相思树下许下的愿，失落了几许凄凄惨惨。还记得，那转身说再见的夜晚，打湿了诗人唯美的诗篇。\r\n　　邂逅在那唯美里，相思何苦，只是遥不可及罢了。牵手在这长亭晚霞中，相思何苦，只不过是那朝朝暮暮而已。挥手在那星光闪烁下，相思何苦，只可惜你远去在黑夜里。\r\n　　你若春风化雨，我欲秋来梦你，你似夏日炎炎，我却冷在风雪里。森林愈广，独眷如你，岁月如歌，唱一曲相见恨晚;长亭晚霞，唯怜若你，相爱如诗，吟一首相思耳畔。山花烂漫，唯美似你，美景如画，画一卷前世恩怨。而你，从画里来，走进我心里······', '47', '2017-05-19');
INSERT INTO `te_article` VALUES ('17', 'Markdown 语法的简要规则', '标题\r\n![输入图片说明](http://ww1.sinaimg.cn/large/6aee7dbbgw1effeaclhiyj20eh09cwez.jpg &quot;在这里输入图片标题&quot;)\r\n标题\r\n标题\r\n标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。\r\n\r\n# 一级标题\r\n\r\n## 二级标题\r\n\r\n### 三级标题\r\n\r\n以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。\r\n\r\n列表\r\n\r\n熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。\r\n\r\n无序列表与有序列表\r\n无序列表与有序列表\r\n引用\r\n\r\n如果你需要引用一小段别处的句子，那么就要用引用的格式。\r\n\r\n例如这样\r\n只需要在文本前加入 &gt; 这种尖括号（大于号）即可\r\n\r\n引用\r\n引用\r\n图片与链接\r\n\r\n插入链接与插入图片的语法很像，区别在一个 !号\r\n\r\n图片为：![](){ImgCap}{/ImgCap}\r\n\r\n链接为：[]()\r\n\r\n插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。\r\n\r\nURL 与图片\r\nURL 与图片\r\n粗体与斜体\r\n\r\nMarkdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。\r\n\r\n例如：这里是粗体 这里是斜体\r\n\r\n表格\r\n\r\n表格是我觉得 Markdown 比较累人的地方，例子如下：\r\n\r\n| Tables        | Are           | Cool  |\r\n| ------------- |:-------------:| -----:|\r\n| col 3 is      | right-aligned | $1600 |\r\n| col 2 is      | centered      |   $12 |\r\n| zebra stripes | are neat      |    $1 |\r\n这种语法生成的表格如下：\r\n\r\nTables	Are	Cool\r\ncol 3 is	right-aligned	$1600\r\ncol 2 is	centered	$12\r\nzebra stripes	are neat	$1\r\n代码框\r\n\r\n如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例：\r\n\r\n\r\n使用 tab 键即可缩进。\r\n\r\n分割线\r\n\r\n分割线的语法只需要三个 * 号，例如：\r\n\r\n到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。\r\n', '47', '2017-05-19');
INSERT INTO `te_article` VALUES ('25', '常见浏览器兼容性问题', '初学html和css时，每天切图，总会遇到很多浏览器兼容性问题。最近一直关注移动平台开发，就html和css来说，不用考虑那么多浏览器兼容性问题。到现在，以至于很多浏览器兼容性几乎忘光了。今天把以前总结的知识拿来分享一下，顺便自己也复习一下。当然，其中肯定有很多不足，望指正啊。\r\n \r\n1 ie6.0横向margin加倍\r\n\r\n产生因素：块属性、float、有横向margin。\r\n解决方法：display：inline；\r\n2 ie6.0下默认有行高\r\n\r\n解决方法：overflow:hidden;或font-size:0;或line-height：xx px；\r\n3 在各个浏览器下img有空隙(原因是：回车。)\r\n\r\n解决方法:让图片浮动。\r\n4 一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。\r\n\r\n解决方法：a 在子标签最后清浮动{&lt;div style=&quot;height:0;clear:both;&quot;&gt;&amp;nbsp;&lt;/div&gt;}\r\n                  b 父标签添加{overflow：hidden；}\r\n                  c 给父标签设置高度\r\n5 Ie6下，不识别最大宽、高度和最小宽高度，意即min-width/height和 Max-width/height在ie6中没效果，\r\n\r\n解决方法：(1)：.abc{border:1px blue solid;width:200px;height:200px;}\r\n                          html&gt;body .abc{width:auto;height:auto;min-width:200px;min-height:200px;}\r\n        (2)：.abc{width:200px;height:200px;_width:200px;_height:200px;}（因为ie6有一个特征，当定义一个高度时，如果内容超过高度，元素会自动调整高度。）\r\n6 Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距\r\n\r\n解决方法：li不设宽、高或者li内的标签不浮动\r\n7  li之间有间距\r\n\r\n解决方法：li 设置vertical-align:middle;\r\n8 3像素问题：ie6下，当浮动元素与流动元素并列显示时，他们之间会存在三像素问题。\r\n\r\n   解决方法：用hack技术， 例如：所有浏览器通用 height:100px; \r\n                                                  ie6专用_height:100px;\r\n                                                  ie7专用*+height:100px; \r\n                                                  ie6/ie7共用*height:100px;\r\n9 当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。\r\n\r\n    解决方法：在行内元素里加入{zoom：1；}\r\n10 当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100%，则在下一行多显示一个上一行最后一个字符。\r\n\r\n        解决办法：给浮动元素添加display:inline;。\r\n11 opacity 定义元素的不透明度\r\n\r\n  filter：alpha（opacity=80）；/*ie支持该属性*/\r\n  opacity：0.8；/*支持css3的浏览器*/\r\n12 两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。\r\n\r\n13 优先级：被!important 注明的css属性具有最高优先级(.abc{color:red !important;})。但在ie6中!important具有一个bug:在同一组css属性中，!important不起作用。\r\n\r\n14 火狐不识别background-position-y 或background-position-x;\r\n\r\n \r\n---------------------------2014.01.10补充-------------------------------\r\n15 ie6 不支持 fixed \r\n\r\n复制代码\r\n/*对于非IE6可以这样写*/\r\n#top{  \r\n    position:fixed;  \r\n    bottom:0;  \r\n    right:20px;  \r\n}  \r\n\r\n/*但是IE6是不支持fixed定位的，需要另外重写*/\r\n#top{  \r\n    position:fixed;  \r\n    _position:absolute;  \r\n    top:0;  \r\n    right:20px;  \r\n    _bottom:auto;  \r\n    _top:expression(eval(document.documentElement.scrollTop));\r\n}  \r\n\r\n/*使用hack使IE6实现该效果，但这个东东会闪烁，需要以下代码*/\r\n*html{  \r\n    background-image:url(about:blank);  \r\n    background-attachment:fixed;  \r\n}  \r\n\r\n/*使固定在顶部*/\r\n#top{  \r\n    _position:absolute;  \r\n    _bottom:auto;  \r\n    _top:expression(eval(document.documentElement.scrollTop));  \r\n}  \r\n\r\n/*固定在底部*/\r\n#top{  \r\n    _position:absolute;  \r\n    _bottom:auto;  \r\n    _top:expression(eval(document.documentElement.scrollTop+document.documentElement.clientHeight-this.offsetHeight-(parseInt(this.currentStyle.marginTop)||0)-(parseInt(this.currentStyle.marginBottom)||0)));  \r\n}  \r\n/*垂直居中*/\r\n#top{\r\n    position:fixed;\r\n    top:50%;\r\n    margin-top:-50px;\r\n    _position:absolute;\r\n    _top:expression(eval(document.documentElement.scrollTop+document.documentElement.clientHeight/2)); \r\n}\r\n复制代码\r\n16  解决 ie6 最大、最小宽高 hack方法\r\n\r\n复制代码\r\n/* 最小宽度 */\r\n.min_width{\r\n    min-width:300px;\r\n    _width:expression(parseInt(this.clientWidth) &lt; 300 ? &quot;300px&quot; : this.clientWidth);\r\n}\r\n\r\n/* 最大宽度 */\r\n.max_width{\r\n   max-width:600px;\r\n   _width:expression(parseInt(this.clientWidth) &gt; 600 ? &quot;600px&quot; : this.clientWidth);\r\n}\r\n\r\n/* 最小高度 */\r\n.min_height{\r\n   min-height:200px;\r\n   _height:expression(parseInt(this.clientHeight) &lt; 200 ? &quot;200px&quot; : this.clientHeight);\r\n}\r\n\r\n/* 最大高度 */\r\n.max_height{\r\n   max-height:400px;\r\n   _height:expression(parseInt(this.clientHeight) &gt; 400 ? &quot;400px&quot; : this.clientHeight);\r\n}\r\n复制代码\r\n \r\n17  z-index不起作用的 bug\r\n\r\n1）ie6下 首先讲讲第一种z-index无论设置多高都不起作用情况。这种情况发生的条件有三个：1、父标签position属性为relative；2、问题标签含有浮动(float)属性。\r\n2）所有浏览器：它只认第一个爸爸\r\n层级的高低不仅要看自己，还要看自己的老爸这个后台是否够硬。用术语具体描述为：\r\n父标签position属性为relative或absolute时，子标签的absolute属性是相对于父标签而言的。而在IE6下，层级的表现有时候不是看子标签的z-index多高，而要看它们的父标签的z-index谁高谁低。\r\n18  ie各个版本hack\r\n\r\n复制代码\r\n/*类内部hack：*/\r\n    .header {_width:100px;}            /* IE6专用*/\r\n    .header {*+width:100px;}        /* IE7专用*/\r\n    .header {*width:100px;}            /* IE6、IE7共用*/\r\n    .header {width:100px\\0;}        /* IE8、IE9共用*/\r\n    .header {width:100px\\9;}        /* IE6、IE7、IE8、IE9共用*/\r\n    .header {width:330px\\9\\0;}    /* IE9专用*//*选择器Hack：*/\r\n    *html .header{}        /*IE6*/ \r\n    *+html .header{}    /*IE7*/', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('23', '禁止网站被别人通过iframe引用', '这种问题有一般有这么几种解决方案：\r\n\r\n解决方案一：js方法\r\n这种方法不可靠，不推荐使用\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\nif(self != top) { top.location = self.location; }\r\n&lt;/script\r\n\r\n把上面的JS代码片段放到你页面的 head 中即可。\r\n\r\n解决方案二：Meta标签方法\r\n&lt;meta http-equiv=&quot;X-FRAME-OPTIONS&quot; content=&quot;DENY&quot;&gt;\r\n\r\n\r\n以上两种为前端处理方法，就我个人来说不推荐使用，不过这个也是因人而异的，没有绝对的好与差。\r\n\r\n解决方案三：PHP方法\r\n&lt;code&gt;&lt;code&gt;&lt;?php header(‘X-Frame-Options:Deny\'); ?&gt;&lt;/code&gt;&lt;/code&gt;\r\n\r\n\r\n上面这种是后端程序处理方法。\r\n\r\n解决方案四：Apache主机方法\r\nHeader always append X-Frame-Options SAMEORIGIN\r\n\r\n\r\n解决方案五：Nginx主机方法\r\nadd_header X-Frame-Options &quot;SAMEORIGIN&quot;;\r\n\r\n\r\n解决方案六：.htaccess方法\r\n在网站根目录下的.htaccess文件中中加一句\r\nHeader append X-FRAME-OPTIONS &quot;SAMEORIGIN&quot;\r\n\r\n\r\n解决方案七：IIS方法\r\n在web.config文件中加\r\n  &lt;system.webServer&gt;\r\n    ...\r\n\r\n    &lt;httpProtocol&gt;\r\n    &lt;customHeaders&gt;\r\n    &lt;add name=&quot;X-Frame-Options&quot; value=&quot;SAMEORIGIN&quot; /&gt;\r\n    &lt;/customHeaders&gt;\r\n    &lt;/httpProtocol&gt;\r\n\r\n    ...\r\n    &lt;/system.webServer&gt;\r\n\r\n\r\n以上四种解决方案为服务器端解决方案。\r\n\r\n方案列了不少，大家自己选吧，我觉的总有一种是适合你的。', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('24', '浏览器兼容性问题概述', '所谓的浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。所以浏览器的兼容性问题是前端开发人员经常会碰到和必须要解决的问题。\r\n在学习浏览器兼容性之前，我想把前端开发人员划分为两类：\r\n第一类是精确按照设计图开发的前端开发人员，可以说是精确到1px的，他们很容易就会发现设计图的不足，并且在很少的情况下会碰到浏览器的兼容性问题，而这些问题往往都死浏览器的bug，并且他们制作的页面后期易维护，代码重用问题少，可以说是比较牢固放心的代码。\r\n第二类是基本按照设计图来开发的前端开发人员，很多细枝末节差距很大，不如间距，行高，图片位置等等经常会差几px。某种效果的实现也是反复调试得到，具体为什么出现这种效果还模模糊糊，整体布局十分脆弱。稍有改动就乱七八糟。代码为什么这么写还不知所以然。这类开发人员往往经常为兼容性问题所困。修改好了这个浏览器又乱了另一个浏览器。改来改去也毫无头绪。其实他们碰到的兼容性问题大部分不应该归咎于浏览器，而是他们的技术本身了。\r\n文章主要针对的是第一类，严谨型的开发人员，因此这里主要从浏览器解析差异的角度来分析兼容性问题。（相关文章推荐：主流浏览器CSS 3和HTML 5兼容清单）\r\n浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同\r\n问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。\r\n碰到频率:100%\r\n解决方案：CSS里    *{margin:0;padding:0;}\r\n备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。\r\n浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大\r\n问题症状:常见症状是IE6中后面的一块被顶到下一行\r\n碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）\r\n解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性\r\n备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。\r\n浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度\r\n问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度\r\n碰到频率：60%\r\n解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。\r\n备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。\r\n浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug\r\n问题症状：IE6里的间距比超过设置的间距\r\n碰到几率：20%\r\n解决方案：在display:block;后面加入display:inline;display:table;\r\n备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。\r\n浏览器兼容问题五：图片默认有间距\r\n问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。\r\n碰到几率：20%\r\n解决方案：使用float属性为img布局\r\n备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）\r\n浏览器兼容问题六：标签最低高度设置min-height不兼容\r\n问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容\r\n碰到几率：5%\r\n解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}\r\n备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。\r\n浏览器兼容问题七：透明度的兼容CSS设置\r\n做兼容页面的方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的新手使用。很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。\r\n/* CSS hack*/ \r\n我很少使用hacker的，可能是个人习惯吧，我不喜欢写的代码IE不兼容，然后用hack来解决。不过hacker还是非常好用的。使用hacker我可以把浏览器分为3类：IE6 ；IE7和遨游；其他（IE8 chrome ff safari opera等）\r\n◆IE6认识的hacker 是下划线_ 和星号 *\r\n◆IE7 遨游认识的hacker是星号 *\r\n比如这样一个CSS设置：\r\nheight:300px;*height:200px;_height:100px; \r\nIE6浏览器在读到height:300px的时候会认为高时300px；继续往下读，他也认识*heihgt， 所以当IE6读到*height:200px的时候会覆盖掉前一条的相冲突设置，认为高度是200px。继续往下读，IE6还认识_height,所以他又会覆盖掉200px高的设置，把高度设置为100px；\r\nIE7和遨游也是一样的从高度300px的设置往下读。当它们读到*height200px的时候就停下了，因为它们不认识_height。所以它们会把高度解析为200px，剩下的浏览器只认识第一个height:300px;所以他们会把高度解析为300px。因为优先级相同且想冲突的属性设置后一个会覆盖掉前一个，所以书写的次序是很重要的。', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('27', '数据结构与算法汇总', '1、常见数据结构\r\n线性：数组，链表，队列，堆栈，块状数组（数组+链表），hash表，双端队列，位图（bitmap）\r\n树：堆（大顶堆、小顶堆），trie树（字母树or字典树），后缀树，后缀树组，二叉排序/查找树，B+/B-，AVL树，Treap，红黑树，splay树，线段树，树状数组\r\n图：图\r\n其它：并查集\r\n2、常见算法\r\n（1）       基本思想：枚举，递归，分治，模拟，贪心，动态规划，剪枝，回溯\r\n（2）       图算法：深度优先遍历与广度优先遍历， 最短路径，最小生成树，拓扑排序\r\n（3）       字符串算法：字符串查找，hash算法，KMP算法\r\n（4）       排序算法：冒泡，插入，选择，快排，归并排序，堆排序，桶排序\r\n（5）       动态规划：背包问题，最长公共子序列，最优二分检索树\r\n（6）       数论问题：素数问题，整数问题，进制转换，同余模运算，\r\n（7）       排列组合：排列和组合算法\r\n（8）       其它：LCA与RMQ问题\r\n', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('28', 'HTML标签marquee实现滚动效果', '页面的自动滚动效果，可由javascript来实现，但是今天无意中发现了一个html标签 - &lt;marquee&gt;&lt;/marquee&gt;可以实现多种滚动效果，无需js控制。\r\n使用marquee标记不仅可以移动文字，也可以移动图片，表格等.\r\n语法：&lt;marquee&gt;...&lt;/marquee&gt;； 说明：在标记之间添加要进行滚动的内容。\r\n重要属性：\r\n1.滚动方向direction（包括4个值：up、 down、 left和 right）\r\n　　语法：&lt;marquee direction=&quot;滚动方向&quot;&gt;...&lt;/marquee&gt;\r\n2.滚动方式behavior（scroll:循环滚动，默认效果； slide:只滚动一次就停止； alternate:来回交替进行滚动）\r\n　　语法：&lt;marquee behavior=&quot;滚动方式&quot;&gt;...&lt;/marquee&gt;\r\n3.滚动速度scrollamount（滚动速度是设置每次滚动时移动的长度，以像素为单位）\r\n　　语法：&lt;marquee scrollamount=&quot;5&quot;&gt;...&lt;/marquee&gt;\r\n4.滚动延迟scrolldelay（设置滚动的时间间隔，单位是毫秒）\r\n　　语法：&lt;marquee scrolldelay=&quot;100&quot;&gt;...&lt;/marquee&gt;\r\n5.滚动循环loop（默认值是-1，滚动会不断的循环下去）\r\n　　语法：&lt;marquee loop=&quot;2&quot;&gt;...&lt;/marquee&gt;\r\n6.滚动范围width、height\r\n7.滚动背景颜色bgcolor\r\n8.空白空间hspace、vspace\r\n 代码示例：\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\r\n&lt;title&gt;文字轮播&lt;/title&gt;\r\n&lt;/head&gt;\r\n\r\n&lt;body&gt;\r\n&lt;div&gt;\r\n    &lt;marquee  scrollamount=5  onmouseover=stop() onmouseout=start() style=&quot;display:block;font-size: 32pt; filter: glow(color=red); width: 940px; margin: 100px auto; color: red; line-height: 1; font-family: 黑体&quot;&gt;\r\n        &lt;b&gt;欢迎光临“我的联盟论坛”，祝大家中秋节快乐！论坛发展中，寻找有责任心得版主&lt;/b&gt;\r\n    &lt;/marquee&gt;\r\n&lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('29', '响应式手机端网站viewpoint失效问题', '响应式网站之前绑定了一个域名，如果再用代理域名做跳转，可以用html跳转，js跳转，不要用框架，因为viewport会失效，解决方案：\r\n\r\n1.两个域名解析到一个ip（即两个域名解析同一套代码）\r\n\r\n2.如果用框架frameset跳转，那么在相应根目录写的index.html文件中加入viewport\r\n\r\n3.使用html跳转或者js跳转', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('30', 'Js根据手机操作系统跳转到手机端', ' function browserRedirect() { \r\n\r\n        var sUserAgent= navigator.userAgent.toLowerCase(); \r\n\r\n        var bIsIpad= sUserAgent.match(/ipad/i) == &quot;ipad&quot;; \r\n\r\n        var bIsIphoneOs= sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; \r\n\r\n        var bIsMidp= sUserAgent.match(/midp/i) == &quot;midp&quot;; \r\n\r\n        var bIsUc7= sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; \r\n\r\n        var bIsUc= sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; \r\n\r\n        var bIsAndroid= sUserAgent.match(/android/i) == &quot;android&quot;; \r\n\r\n        var bIsCE= sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; \r\n\r\n        var bIsWM= sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; \r\n\r\n        if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { \r\n\r\n            window.location.href= \'手机网站地址\'; \r\n\r\n        } else { \r\n\r\n            window.location= \'电脑网站地址\'; \r\n\r\n        } \r\n\r\n    } \r\n\r\n    browserRedirect(); ', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('31', '完美运动框架', 'function getStyle(obj, attr)\r\n{\r\n if(obj.currentStyle)\r\n {\r\n  return obj.currentStyle[attr];\r\n }\r\n else\r\n {\r\n  return getComputedStyle(obj, false)[attr];\r\n }\r\n}\r\nfunction startMove(obj, json, fn)\r\n{\r\n clearInterval(obj.timer);\r\n obj.timer=setInterval(function (){\r\n  var bStop=true;  //这一次运动就结束了——所有的值都到达了\r\n  for(var attr in json)\r\n  {\r\n       //1.取当前的值\r\n       var iCur=0;\r\n   \r\n       if(attr==\'opacity\')\r\n       {\r\n         iCur=parseInt(parseFloat(getStyle(obj, attr))*100);\r\n       }\r\n       else\r\n      {\r\n         iCur=parseInt(getStyle(obj, attr));\r\n      }\r\n   \r\n      //2.算速度\r\n      var iSpeed=(json[attr]-iCur)/8;\r\n      iSpeed=iSpeed&gt;0?Math.ceil(iSpeed):Math.floor(iSpeed);\r\n   \r\n      //3.检测停止\r\n      if(iCur!=json[attr])\r\n      {\r\n       bStop=false;\r\n      }\r\n   \r\n       if(attr==\'opacity\')\r\n     {\r\n       obj.style.filter=\'alpha(opacity:\'+(iCur+iSpeed)+\')\';\r\n       obj.style.opacity=(iCur+iSpeed)/100;\r\n     }\r\n      else\r\n     {\r\n       obj.style[attr]=iCur+iSpeed+\'px\';\r\n     }\r\n}\r\n  \r\n  if(bStop)\r\n  {\r\n   clearInterval(obj.timer);\r\n   \r\n   if(fn)\r\n   {\r\n    fn();\r\n   }\r\n  }\r\n }, 30)\r\n}', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('32', 'ajax异步和同步的区别', '一、async值为true （异步）\r\n\r\n当ajax发送请求后，在等待server端返回的这个过程中，前台会继续 执行ajax块后面的脚本，直到server端返回正确的结果才会去执行success，也就是说这时候执行的是两个线程，ajax块发出请求后一个线程 和ajax块后面的脚本（另一个线程）\r\n$.ajax({ \r\n     type:&quot;POST&quot;,\r\n     url:&quot;Venue.aspx?act=init&quot;,\r\n      dataType:&quot;html&quot;,\r\n     success:function(result){  //function1()\r\n       f1();\r\n       f2(); \r\n    }\r\n     failure:function(result) { \r\n      alert(\'Failed\'); \r\n     },\r\n }\r\n function2();\r\n\r\n二、async值为false （同步）\r\n\r\n当执行当前AJAX的时候会停止执行后面的JS代码，直到AJAX执行完毕后时，才能继续执行后面的JS代码。\r\n$.ajax({ \r\n     type:&quot;POST&quot;,\r\n     url:&quot;Venue.aspx?act=init&quot;,\r\n     dataType:&quot;html&quot;,\r\n     async: false,\r\n    success:function(result){  //function1()\r\n       f1();\r\n       f2();\r\n     }\r\n    failure:function(result) { \r\n      alert(\'Failed\'); \r\n     },\r\n }\r\n function2();\r\n\r\n三、异步可以优化用户体验，无需等待就可以做其他操作，为什么异步这么好，还要同步。当这一步的结果是下一步的前提，这个时候就要使用同步\r\n\r\n四、ajax请求超时\r\n\r\n\r\nfunctionload(){\r\n        $(&quot;#tips&quot;).html(&quot;加载中...&quot;);//此处可以设置加载动画\r\n        $.ajax({\r\n          async:true,\r\n          cache:false,\r\n          timeout:8000,\r\n          type:&quot;POST&quot;,\r\n          url:&quot;result.php&quot;,\r\n          data:{a:\'123\'},\r\n          success:function(msg){\r\n            $(&quot;#tips&quot;).html(msg);\r\n          }，\r\n          error:function(jqXHR, textStatus, errorThrown){\r\n            if(textStatus==&quot;timeout&quot;){\r\n              $(&quot;#tips&quot;).html(&quot;加载超时，请重试&quot;);\r\n            }else{\r\n              alert(textStatus);\r\n            }\r\n          }\r\n          \r\n        });\r\n }\r\n\r\n\r\n\r\n', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('33', '原生js面向对象的编写方式 ', '原生js面向对象有两种方式（面向对象其实就是封装，继承，多态。我对面向对象的理解还有一种，前端就是原型，后端就是框架）\r\n\r\n1.工厂模式（缺点，只有一个new，所有对象具有相同的方法）\r\nfunctionfn(a,b){//创建原料var obj = newObject();\r\n\r\n    //加工产品\r\n    obj.name = name;\r\n    obj.yongchu = function(){\r\n        alert(&quot;obj的用途是XXX&quot;)\r\n    }\r\n\r\n    //产品出厂return obj;\r\n}\r\n\r\nvar obj = fn(&quot;one&quot;,&quot;eat&quot;); //没有new关键字var obj2 = fn(&quot;two&quot;,&quot;eat&quot;);\r\nobj.yongchu();\r\nalert(obj.yongchu == obj2.yongchu) //false功能一样却不相等，同样功能占用了更多的内存，浪费。\r\n\r\n2.原型对象\r\n\r\n实现方法：由构造函数和原型组成，构造函数里写对象的属性，原型里写对象的方法。使用时，先实例化构造函数（js没有类）得到原型对象（构造对象），再调用原型方法。\r\n\r\nfunction CreatePerson(name,qq){ //构造函数里面写属性，类名CreatePerson首字母大写\r\nthis.name = name;\r\n        this.qq = qq;\r\n    }\r\n\r\n    createPerson.prototype.showName = function(){//原型里面写方法\r\n        alert(&quot;我的名字&quot; + this.name);\r\n    }\r\n\r\n    createPerson.prototype.showQQ = function(){\r\n        alert(&quot;我的QQ&quot; + this.qq);\r\n    }\r\n\r\n    var obj = new createPerson(&quot;mike&quot;,&quot;123456&quot;);\r\n    obj.showName();\r\n    obj.showQQ();\r\n\r\n原型对象之间可以通过call（this，属性）方法继承构造对象中的属性，可以通过原型重新指向构造对象（之前的原型方法没有了）来继承原型方法（继承了新的原型方法），相当于修改了构造函数。继承之后，原型对象之间会形成内置的_porto_原型链，比如下面，A构造的B的原型，A是上级，B是下级。注意：constructor的值是一个函数，比如String(),Function()等\r\n\r\nfunction A(x){\r\n this.x = x;\r\n }\r\n A.prototype.a =&quot;a&quot;;\r\n\r\n function B(x,y){\r\n this.y = y;\r\n 　　A.call(this,x);\r\n }\r\n B.prototype.b1 =function(){\r\n 　　alert(&quot;b1&quot;);\r\n }\r\n方法1：\r\n B.prototype =new A();\r\n B.prototype.b2 =function(){ //注意这步是定义B原型的方法，不会影响A原型\r\n 　　alert(&quot;b2&quot;);\r\n }\r\n var obj =new B(1,3);\r\n\r\n方法2：\r\n\r\nB.prototype = A.prototype\r\nB.prototype.b2 = function(){ //注意这步是定义B原型的方法，不会影响A原型\r\n 　　alert(&quot;b2&quot;);\r\n }\r\n var obj = new B(1,3);\r\n\r\n还可以还原B的构造函数，这样就又居有原来的原型方法b1。所有原型对象中每个对象可以具有不同的方法\r\nB.prototype.constructor = B;\r\n\r\n\r\n', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('34', 'Html5新标签解释及用法', 'Html5新标签解释及用法\r\nHTML 5 是一个新的网络标准，目标在于取代现有的 HTML 4.01, XHTML 1.0 and DOM Level 2 HTML 标准。它希望能够减少浏览器对于需要插件的丰富性网络应用服务（plug-in-based rich internet application，RIA)，如Adobe Flash, Microsoft Silverlight, 与 Sun JavaFX 的需求。\r\nHTML 5 提供了一些新的元素和属性，反映典型的现代用法网站。其中有些是技术上类似 &lt;div&gt; 和 &lt;span&gt; 标签，但有一定含义，例如 &lt;nav&gt;（网站导航块）和 &lt;footer&gt;。这种标签将有利于搜索引擎的索引整理、小屏幕装置和视障人士使用。同时为其他浏览要素提供了新的功能，通过一个标准接口，如 &lt;audio&gt;和 &lt;video&gt; 标记。\r\n之前的一篇：HTML5 Shiv – 让该死的IE系列支持HTML5吧介绍了如何让所有浏览器都支持html5标签，你可以放心大胆的用了！\r\n一些过时的 HTML 4 标记将取消，其中包括纯粹用作显示效果的标记，如 &lt;font&gt; 和 &lt;center&gt;，因为它们已经被 CSS 取代。还有一些透过 DOM 的网络行为（via）。\r\n下面我们来看一下HTML 5提供的一些新的标签用法以及和HTML 4的区别。\r\n&lt;article&gt;标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。\r\nHTML5:&lt;article&gt;&lt;/article&gt;\r\nHTML4:&lt;div&gt;&lt;/div&gt;\r\n&lt;aside&gt;标签定义 article 以外的内容。aside 的内容应该与 article 的内容相关。\r\nHTML5:&lt;aside&gt;Aside 的内容是独立的内容，但应与文档内容相关。&lt;/aside&gt;\r\nHTML4:&lt;div&gt;Aside 的内容是独立的内容，但应与文档内容相关。&lt;/div&gt;\r\n&lt;audio&gt; 标签定义声音，比如音乐或其他音频流。\r\nHTML5:&lt;audio src=&quot;someaudio.wav&quot;&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt;\r\nHTML4:&lt;object type=&quot;application/ogg&quot; data=&quot;someaudio.wav&quot;&gt;&lt;param name=&quot;src&quot; value=&quot;someaudio.wav&quot;&gt;&lt;/object&gt;\r\n&lt;canvas&gt; 标签定义图形，比如图表和其他图像。这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。\r\nHTML5:&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;\r\nHTML4:&lt;object data=&quot;inc/hdr.svg&quot; type=&quot;image/svg+xml&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/object&gt;\r\n&lt;command&gt; 标签定义命令按钮，比如单选按钮、复选框或按钮。\r\nHTML5: &lt;command onclick=cut()&quot; label=&quot;cut&quot;&gt;\r\nHTML4: none\r\n&lt;datalist&gt; 标签定义可选数据的列表。与 input 元素配合使用，就可以制作出输入值的下拉列表。\r\nHTML5: &lt;datalist&gt;&lt;/datalist&gt;\r\nHTML4: see combobox.\r\n&lt;details&gt; 标签定义元素的细节，用户可进行查看，或通过点击进行隐藏。与 &lt;legend&gt; 一起使用，来制作 detail 的标题。该标题对用户是可见的，当在其上点击时可打开或关闭 detail。\r\nHTML5: &lt;details&gt;&lt;/details&gt;\r\nHTML4: &lt;dl style=&quot;display:hidden&quot;&gt;&lt;/dl&gt;\r\n&lt;embed&gt; 标签定义嵌入的内容，比如插件。\r\nHTML5: &lt;embed src=&quot;horse.wav&quot; /&gt;\r\nHTML4: &lt;object data=&quot;flash.swf&quot;  type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;\r\n&lt;figcaption&gt; 标签定义 figure 元素的标题。”figcaption” 元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置。\r\nHTML5: &lt;figure&gt;&lt;figcaption&gt;PRC&lt;/figcaption&gt;&lt;/figure&gt;\r\nHTML4: none\r\n&lt;figure&gt; 标签用于对元素进行组合。使用 &lt;figcaption&gt; 元素为元素组添加标题。\r\nHTML5: &lt;figure&gt;&lt;figcaption&gt;PRC&lt;/figcaption&gt;&lt;p&gt;The People\'s Republic of China was born in 1949...&lt;/p&gt;&lt;/figure&gt;\r\nHTML4: &lt;dl&gt;&lt;h1&gt;PRC&lt;/h1&gt;&lt;p&gt;The People\'s Republic of China was born in 1949...&lt;/p&gt;&lt;/dl&gt;\r\n&lt;footer&gt; 标签定义 section 或 document 的页脚。典型地，它会包含创作者的姓名、文档的创作日期以及/或者联系信息。\r\nHTML5: &lt;footer&gt;&lt;/footer&gt;\r\nHTML4: &lt;div&gt;&lt;/div&gt;\r\n&lt;header&gt; 标签定义 section 或 document 的页眉。\r\nHTML5: &lt;header&gt;&lt;/header&gt;\r\nHTML4: &lt;div&gt;&lt;/div&gt;\r\n&lt;hgroup&gt; 标签用于对网页或区段（section）的标题进行组合。\r\nHTML5: &lt;hgroup&gt;&lt;/hgroup&gt;\r\nHTML4: &lt;div&gt;&lt;/div&gt;\r\n&lt;keygen&gt; 标签定义生成密钥。\r\nHTML5: &lt;keygen&gt;\r\nHTML4: none\r\n&lt;mark&gt;主要用来在视觉上向用户呈现那些需要突出的文字。&lt;mark&gt;标签的一个比较典型的应用就是在搜索结果中向用户高亮显示搜索关键词。\r\nHTML5: &lt;mark&gt;&lt;/mark&gt;\r\nHTML4: &lt;span&gt;&lt;/span&gt;\r\n&lt;meter&gt; 标签定义度量衡。仅用于已知最大和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。\r\nHTML5: &lt;meter&gt;&lt;/meter&gt;\r\nHTML4: none\r\n&lt;nav&gt; 标签定义导航链接的部分。\r\nHTML5: &lt;nav&gt;&lt;/nav&gt;\r\nHTML4:&lt;ul&gt;&lt;/ul&gt;\r\n&lt;output&gt; 标签定义不同类型的输出，比如脚本的输出。\r\nHTML5: &lt;output&gt;&lt;/output&gt;\r\nHTML4: &lt;span&gt;&lt;/span&gt;\r\n&lt;progress&gt; 标签运行中的进程。可以使用 &lt;progress&gt; 标签来显示 JavaScript 中耗费时间的函数的进程。\r\nHTML5: &lt;progress&gt;&lt;/progress&gt;\r\nHTML4: none\r\n&lt;rp&gt; 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。\r\nHTML5: &lt;ruby&gt;漢 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;/ruby&gt;\r\nHTML4: none\r\n&lt;rt&gt; 标签定义字符（中文注音或字符）的解释或发音。\r\nHTML5: &lt;ruby&gt;漢 &lt;rt&gt; ㄏㄢˋ &lt;/rt&gt;&lt;/ruby&gt;\r\nHTML4: none\r\n&lt;ruby&gt; 标签定义 ruby 注释（中文注音或字符）。\r\nHTML5: &lt;ruby&gt;漢 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;/ruby&gt;\r\nHTML4: none\r\n&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。\r\nHTML5: &lt;section&gt;&lt;/section&gt;\r\nHTML4: &lt;div&gt;&lt;/div&gt;\r\n&lt;source&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。\r\nHTML5: &lt;source&gt;\r\nHTML4: &lt;param&gt;\r\n&lt;summary&gt; 标签包含 details 元素的标题，”details” 元素用于描述有关文档或文档片段的详细信息。”summary” 元素应该是 “details” 元素的第一个子元素。\r\nHTML5: &lt;details&gt;&lt;summary&gt;HTML 5&lt;/summary&gt;This document teaches you everything you have to learn about HTML 5.&lt;/details&gt;\r\nHTML4: none\r\n&lt;time&gt; 标签定义日期或时间，或者两者。\r\nHTML5: &lt;time&gt;&lt;/time&gt;\r\nHTML4: &lt;span&gt;&lt;/span&gt;\r\n&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。\r\nHTML5: &lt;video src=&quot;movie.ogg&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt;\r\nHTML4:&lt;object type=&quot;video/ogg&quot; data=&quot;movie.ogv&quot;&gt;&lt;param name=&quot;src&quot; value=&quot;movie.ogv&quot;&gt;&lt;/object&gt;', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('35', '基于Html5的移动端（APP）开发框架的优缺点', '1.框架：PhoneGap\r\n官网：http://phonegap.com/\r\n简介： PhoneGap是一个用基于HTML，CSS和JavaScript的，创建移动跨平台移动应用程序的快速开发平台。它使开发者能够利用iPhone，Android，Palm,Symbian,WP7,WP8,Bada和Blackberry智能手机的核心功能——包括地理定位，加速器，联系人，声音和振动等，此外PhoneGap拥有丰富的插件，可以调用。\r\n优点：1.可跨平台。phonegap框架帮我们解决了差异性，javascript与平台系统的连接由phonegap框架完成。成为连接移动终端的适配器，或者说中间件。\r\n2.提供硬件访问控制。可调用加速计、摄像头、罗盘、通讯录、文档、地理定位、媒体、网络、通知(警告、声音和振动)、存储。\r\n3.可利用成熟javascript框架。如：Ext js、jQuery。\r\n缺点：1.性能差。运行速度慢，UI反应延时——这是个致命伤。(高端机影响不大)\r\n2.不能完全跨平台。不同平台代码需要微调。\r\n3.内存消耗大。\r\n4.调试难度大。\r\n侧重点：侧重于对硬件的访问控制\r\n\r\n2.框架：Ionic\r\n官网：http://ionicframework.com/\r\n简介： Ionic 是一个强大的 HTML5 应用程序开发框架，号称 Advanced HTML5 Hybrid Mobile AppFramework 是 AngularJS 移动端解决方案 可以帮助您使用 Web 技术，比如 HTML、 CSS 和Javascript 构建接近原生体验的移动应用程序。 Ionic 主要关注外观和体验，以及和你的应用程序的 UI 交互，特别适合用于基于 Hybird 模式的 HTML5 移动应用程序开发。 Ionic 是一个轻量的手机 UI 库，具有速度快，界面现代化、美观等特点。为了解决其他一些UI 库在手机上运行缓慢的问题。\r\n优点：1.追求性能 运行速度快\r\n2.轻量级框架\r\n3.基于 Angularjs，支持 Angularjs的特性， MVC ，代码易维护\r\n4.通过 SASS 构建应用程序。它提供了很多 UI 组件来帮助开发者开发强大的应用。\r\n5.接近原生。\r\n6.强大的命令行工具\r\n3.可利用成熟javascript框架。如：Ext js、jQuery。\r\n缺点：1.Ionic是一个前段框架。不能完全取代PhoneGap和JavaScript框架的作用\r\n2.需要结合插件使用。\r\n侧重点：侧重于前端的交互\r\n\r\n3.框架：Hbuilder（国产）\r\n官网：http://dcloud.io/\r\n简介： HBuilder是DCloud（数字天堂）推出一款支持HTML5的Web开发IDE。“快，是HBuilder的最大优势，通过完整的语法提示和代码输入法、代码块及很多配套，HBuilder能大幅提升HTML、js、css的开发效率。\r\n优点：1、HTML5语法、HTML5+语法、三大浏览器扩展语法，尽收HBuilder中。 \r\n2、每个浏览器发布新版后，一周内，其新增语法就收录入HBuilder。 \r\n3、强大到令你震惊的Jquery语法提示！ \r\n4、每个语法在哪个浏览器、哪个版本上是否可运行，这里都有。 \r\n5、没有比这里更全的语法库，也没有比这里更全的浏览器兼容性数据库。\r\n缺点：1.云端编译，无法保证安全性。\r\n2.不能完全跨平台。不同平台代码需要微调。\r\n侧重点：侧重于编码实现\r\n\r\n4.框架：appcan（国产）\r\n官网：http://www.appcan.cn/\r\n简介：AppCan是国内Hybrid App混合模式开发的倡导者，AppCan应用引擎支持Hybrid App的开发和运行。并且着重解决了基于HTML5的移动应用&quot;不流畅&quot;和&quot;体验差&quot;的问题。使用AppCan应用引擎提供的Native交互能力，可以让HTML5开发的移动应用基本接近Native App的体验。\r\n与Phonegap支持单一webview使用div为单位开发移动应用不同。AppCan支持多窗口机制，让开发者可以像最传统的网页开发一样，通过页面链接的方式灵活的开发移动应用。基于这种机制，开发者可以开发出大型的移动应用，而不是只能开发简易类型的移动应用。\r\nAppCan提供强大的设备调用能力，电话、短信、相机、LBS、传感器、数据库等常用的手机功能，开发者可以通过JS接口调用，轻松构建移动应用。\r\n优点：1.跨平台：同时支持iOS、Android、Symbian、Windows Phone\r\n2.原生体验：引入原生UI控件与交互支持（如Action Sheet等）\r\n3.开发工具：基于Eclipse的开发工具，集成UI控件与应用管理\r\n4.UI框架：提供强大的UI框架，更加易于实现页面布局与交互\r\n5.设备API：支持各种手机设备调用，如电话、相机、传感器、定位等\r\n6.本地打包：无需配置环境，无需编译，本地一键打包\r\n7.插件机制：支持第三方原生插件，支持JS插件\r\n8.代码加密：基于密钥的加密方式，无法破解，像混编一样保护html代码\r\n统计分析：应用分平台安装数统计，应用启动和使用情况统计\r\n9.开放平台：更具本土优势，已经对接Sina、QQ、百度等开放平台\r\n10.技术支持：技术支持及时响应，重视开发者建议和反馈\r\n缺点：1.AppCan免费版因需要把源代码上传到厂商的服务器上打包，对于企业开发来说源代码泄露安全性上有一定风险。企业版虽然可以解决，但企业版稳定尚待观察。\r\n2.AppCan采用封装的组件，依赖性比较高。不是开源代码。\r\n3.AppCan 不能很好的解决原生代码的功能。\r\n侧重点：不知\r\n\r\n5.框架：Wex5(国产)\r\n官网：http://wex5.com/\r\n简介：WeX5应用快速开发框架（含完整的SDK API及全部源码），一次开发、跨端运行。\r\n【定位】开发面向消费者和公众的开放应用系统\r\n【适用】一般app、电商app、客服app、会员app、微店微商等\r\n【前端】安卓app/苹果app/微信服务号/PC web app\r\n【后端】后端数据处理组件，对接各主流技术平台\r\n【费用】完全开源，彻底免费，无任何限制\r\n优点：1.高效精致的UI组件体系，基于jquery和bootstrap技术，采用增强的RequireJS模块化技术。\r\n2.基于phonegap(cordova)框架，如相机、地图、LBS定位、指南针、通讯录、文件、语音、电池等。\r\n3.可视化拖拽式集成开发环境IDE，全能力的调试支持和智能代码提示\r\n缺点：1.使用范围有限：适用：一般app、电商app、客服app、会员app、微店微商等\r\n2.用户量小，存在不稳定因素。\r\n侧重点：不知\r\n\r\n6.框架：ApiCloud(国产)\r\n官网：http://www.apicloud.com/\r\n简介：APICloud是中国领先的“云端一体”的移动应用云服务提供商。APICloud推行“云端一体”的理念，重新定义了移动应用开发。APICloud为开发者从“云”和“端”两个方向提供API，简化移动应用开发技术，让移动应用的开发周期从一个月缩短到7天。APICloud由“云API”和“端API”两部分组成，可以帮助开发者快速实现移动应用的开发、测试、发布、管理和运营的全生命周期管理。\r\nAPICloud致力成为中国领先的移动垂直领域云服务商，帮助传统软件公司从B/S架构成功走向APP，帮助中国数百万web开发者转化成移动APP专家！。\r\n优点：1.提供开发的IDE。\r\n2.提供数据云API、统计云API、推送云API\r\n缺点：与Hbuilder存在版权问题，抄袭Hbuilder\r\n侧重点：不知\r\n\r\n结论：\r\n1.跨平台方面：大部分框架针对android和ios平台，需要做或多或少的代码调整，不能达到完全跨平台。         \r\n2.性能方面：根据不完全统计，Ionic的性能会更好一点。           \r\n3.代码实现方面：Hbuilder具有更高的效率。             \r\n4.PhoneGap出现最早，国内框架都是基于Phonegap开发出来的。\r\n\r\n注意：               \r\n    *关于框架的优缺点众说纷纭，从总体看，hybrid app并没有达到native app的实现效果。           \r\n    *各框架在实现过程中都会遇到不同程度的坑，请根据框架的侧重点谨慎选择应用的框架。           \r\n    *如果要基于Html5开发App，还需要进一步根据需求验证框架的可实施性、并进行不同框架的效果对比。\r\n转自【B5教程网】:http://www.bcty365.com/content-74-2640-1.html', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('36', 'thinkPHP实现注册登录功能', '1.创建数据库 :(略)\r\n2.创建模型(用于自动验证, 自动完成) :\r\nnamespace Home\\Model;\r\nuse Think\\Model;\r\n\r\nclass UsersModel extends Model {\r\n    /**\r\n     * 自动验证\r\n     * self::EXISTS_VALIDATE 或者0 存在字段就验证（默认）\r\n     * self::MUST_VALIDATE 或者1 必须验证\r\n     * self::VALUE_VALIDATE或者2 值不为空的时候验证\r\n     */\r\n    protected $_validate = array(\r\n        array(\'nickname\', \'require\', \'昵称不能为空！\'), //默认情况下用正则进行验证\r\n        array(\'username\', \'require\', \'用户名不能为空！\'), //默认情况下用正则进行验证\r\n        array(\'username\', \'\', \'该用户名已被注册！\', 0, \'unique\', 1), // 在新增的时候验证name字段是否唯一\r\n        array(\'email\', \'\', \'该邮箱已被占用\', 0, \'unique\', 1), // 新增的时候email字段是否唯一\r\n        array(\'mobile\', \'\', \'该手机号码已被占用\', 0, \'unique\', 1), // 新增的时候mobile字段是否唯一\r\n        // 正则验证密码 [需包含字母数字以及@*#中的一种,长度为6-22位]\r\n        array(\'password\', \'/^([a-zA-Z0-9@*#]{6,22})$/\', \'密码格式不正确,请重新输入！\', 0),\r\n        array(\'repassword\', \'password\', \'确认密码不正确\', 0, \'confirm\'), // 验证确认密码是否和密码一致\r\n        array(\'email\', \'email\', \'邮箱格式不正确\'), // 内置正则验证邮箱格式\r\n        array(\'mobile\', \'/^1[34578]\\d{9}$/\', \'手机号码格式不正确\', 0), // 正则表达式验证手机号码\r\n        array(\'verify\', \'verify_check\', \'验证码错误\', 0, \'function\'), // 判断验证码是否正确\r\n        //array(\'agree\', \'is_agree\', \'请先同意网站安全协议！\', 1, \'callback\'), // 判断是否勾选网站安全协议\r\n        array(\'agree\', \'require\', \'请先同意网站安全协议！\', 1), // 判断是否勾选网站安全协议\r\n    );\r\n\r\n    /**\r\n     * 自动完成\r\n     */\r\n    protected $_auto = array (\r\n        array(\'password\', \'md5\', 3, \'function\') , // 对password字段在新增和编辑的时候使md5函数处理\r\n        array(\'regdate\', \'time\', 1, \'function\'), // 对regdate字段在新增的时候写入当前时间戳\r\n        array(\'regip\', \'get_client_ip\', 1, \'function\'), // 对regip字段在新增的时候写入当前注册ip地址\r\n    );\r\n\r\n    /**\r\n     * 判断是否同意网站安全管理协议\r\n     * @return bool\r\n     */\r\n    protected function is_agree()\r\n    {\r\n        // 获取POST数据\r\n        $agree = I(\'post.agree\', 0, \'intval\');\r\n\r\n        // 验证\r\n        if ($agree) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n3.注册登录 :\r\nnamespace Home\\Controller;\r\nuse Think\\Controller;\r\n\r\n/**\r\n * Class LoginController\r\n * @package Home\\Controller\r\n */\r\nclass LoginController extends Controller {\r\n    /**\r\n     * 用户注册\r\n     */\r\n    public function register()\r\n    {\r\n        // 判断提交方式 做不同处理\r\n        if (IS_POST) {\r\n            // 实例化User对象\r\n            $user = D(\'users\');\r\n\r\n            // 自动验证 创建数据集\r\n            if (!$data = $user-&gt;create()) {\r\n                // 防止输出中文乱码\r\n                header(&quot;Content-type: text/html; charset=utf-8&quot;);\r\n                exit($user-&gt;getError());\r\n            }\r\n\r\n            //插入数据库\r\n            if ($id = $user-&gt;add($data)) {\r\n                /* 直接注册用户为超级管理员,子用户采用邀请注册的模式,\r\n                   遂设置公司id等于注册用户id,便于管理公司用户*/\r\n                $user-&gt;where(&quot;userid = $id&quot;)-&gt;setField(\'companyid\', $id);\r\n                $this-&gt;success(\'注册成功\', U(\'Index/index\'), 2);\r\n            } else {\r\n                $this-&gt;error(\'注册失败\');\r\n            }\r\n        } else {\r\n            $this-&gt;display();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 用户登录\r\n     */\r\n    public function login()\r\n    {\r\n        // 判断提交方式\r\n        if (IS_POST) {\r\n            // 实例化Login对象\r\n            $login = D(\'login\');\r\n\r\n            // 自动验证 创建数据集\r\n            if (!$data = $login-&gt;create()) {\r\n                // 防止输出中文乱码\r\n                header(&quot;Content-type: text/html; charset=utf-8&quot;);\r\n                exit($login-&gt;getError());\r\n            }\r\n\r\n            // 组合查询条件\r\n            $where = array();\r\n            $where[\'username\'] = $data[\'username\'];\r\n            $result = $login-&gt;where($where)-&gt;field(\'userid,username,nickname,password,lastdate,lastip\')-&gt;find();\r\n\r\n            // 验证用户名 对比 密码\r\n            if ($result &amp;&amp; $result[\'password\'] == $result[\'password\']) {\r\n                // 存储session\r\n                session(\'uid\', $result[\'userid\']);          // 当前用户id\r\n                session(\'nickname\', $result[\'nickname\']);   // 当前用户昵称\r\n                session(\'username\', $result[\'username\']);   // 当前用户名\r\n                session(\'lastdate\', $result[\'lastdate\']);   // 上一次登录时间\r\n                session(\'lastip\', $result[\'lastip\']);       // 上一次登录ip\r\n\r\n                // 更新用户登录信息\r\n                $where[\'userid\'] = session(\'uid\');\r\n                M(\'users\')-&gt;where($where)-&gt;setInc(\'loginnum\');   // 登录次数加 1\r\n                M(\'users\')-&gt;where($where)-&gt;save($data);   // 更新登录时间和登录ip\r\n\r\n                $this-&gt;success(\'登录成功,正跳转至系统首页...\', U(\'Index/index\'));\r\n            } else {\r\n                $this-&gt;error(\'登录失败,用户名或密码不正确!\');\r\n            }\r\n        } else {\r\n            $this-&gt;display();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 用户注销\r\n     */\r\n    public function logout()\r\n    {\r\n        // 清楚所有session\r\n        session(null);\r\n        redirect(U(\'Login/login\'), 2, \'正在退出登录...\');\r\n    }\r\n\r\n    /**\r\n     * 验证码\r\n     */\r\n    public function verify()\r\n    {\r\n        // 实例化Verify对象\r\n        $verify = new \\Think\\Verify();\r\n\r\n        // 配置验证码参数\r\n        $verify-&gt;fontSize = 14;     // 验证码字体大小\r\n        $verify-&gt;length = 4;        // 验证码位数\r\n        $verify-&gt;imageH = 34;       // 验证码高度\r\n        $verify-&gt;useImgBg = true;   // 开启验证码背景\r\n        $verify-&gt;useNoise = false;  // 关闭验证码干扰杂点\r\n        $verify-&gt;entry();\r\n    }\r\n}\r\n\r\n4.注册模版 :\r\n&lt;div class=&quot;register-box-body&quot;&gt;\r\n        &lt;p class=&quot;login-box-msg&quot;&gt;注册一个新用户&lt;/p&gt;\r\n        &lt;form action=&quot;__SELF__&quot; method=&quot;post&quot;&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;text&quot; name=&quot;nickname&quot; class=&quot;form-control&quot; placeholder=&quot;昵称&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-leaf form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-user form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-credit-card form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;password&quot; name=&quot;repassword&quot; class=&quot;form-control&quot; placeholder=&quot;确认密码&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-check form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;email&quot; name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;邮箱&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-envelope form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;text&quot; name=&quot;mobile&quot; class=&quot;form-control&quot; placeholder=&quot;手机号码&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-phone form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;text&quot; name=&quot;verify&quot; class=&quot;form-control&quot; placeholder=&quot;验证码&quot; style=&quot;width:200px;&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-qrcode form-control-feedback&quot; style=&quot;right:120px;&quot;&gt;&lt;/span&gt;\r\n                &lt;img class=&quot;verify&quot; src=&quot;{:U(verify)}&quot; alt=&quot;验证码&quot; onClick=&quot;this.src=this.src+\'?\'+Math.random()&quot; /&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;row&quot;&gt;\r\n                &lt;div class=&quot;col-xs-8&quot;&gt;\r\n                    &lt;div class=&quot;checkbox icheck&quot;&gt;\r\n                        &lt;label&gt;\r\n                            &lt;input type=&quot;checkbox&quot; name=&quot;agree&quot; value=&quot;1&quot;&gt; 我同意 &lt;a href=&quot;#&quot;&gt;网站安全协议&lt;/a&gt;\r\n                        &lt;/label&gt;\r\n                    &lt;/div&gt;\r\n                &lt;/div&gt;&lt;!-- /.col --&gt;\r\n                &lt;div class=&quot;col-xs-4&quot;&gt;\r\n                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block btn-flat&quot;&gt;点击注册&lt;/button&gt;\r\n                &lt;/div&gt;&lt;!-- /.col --&gt;\r\n            &lt;/div&gt;\r\n        &lt;/form&gt;\r\n        &lt;a href=&quot;login.html&quot; class=&quot;text-center&quot;&gt;我已经注册了账户&lt;/a&gt;\r\n    &lt;/div&gt;\r\n\r\n5.登录模版 :\r\n&lt;form action=&quot;__SELF__&quot; method=&quot;post&quot;&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-user form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-lock form-control-feedback&quot;&gt;&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;form-group has-feedback&quot;&gt;\r\n                &lt;input type=&quot;text&quot; name=&quot;verify&quot; class=&quot;form-control&quot; placeholder=&quot;验证码&quot; style=&quot;width:200px;&quot; /&gt;\r\n                &lt;span class=&quot;glyphicon glyphicon-qrcode form-control-feedback&quot; style=&quot;right:120px;&quot;&gt;&lt;/span&gt;\r\n                &lt;img class=&quot;verify&quot; src=&quot;{:U(verify)}&quot; alt=&quot;验证码&quot; onClick=&quot;this.src=this.src+\'?\'+Math.random()&quot; /&gt;\r\n            &lt;/div&gt;\r\n            &lt;div class=&quot;row&quot;&gt;\r\n                &lt;div class=&quot;col-xs-8&quot;&gt;\r\n                    &lt;div class=&quot;checkbox icheck&quot;&gt;\r\n                        &lt;label&gt;\r\n                            &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot; value=&quot;1&quot;&gt; 记住我\r\n                        &lt;/label&gt;\r\n                    &lt;/div&gt;\r\n                &lt;/div&gt;&lt;!-- /.col --&gt;\r\n                &lt;div class=&quot;col-xs-4&quot;&gt;\r\n                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block btn-flat&quot;&gt;登录&lt;/button&gt;\r\n                &lt;/div&gt;&lt;!-- /.col --&gt;\r\n            &lt;/div&gt;\r\n        &lt;/form&gt;', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('37', 'jquery表单验证插件（jquery.validate.js）', 'Thinkphp实现短信验证注册功能(http://www.jb51.net/article/95038.htm)\r\n\r\njquery  验证非常简单，下面总结常用的三种方式：\r\n第一种方式：也是比较标准的方式：\r\n首先引入jquery  插件和 jquery 验证插件：\r\n第一步：引入插件\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.6.1.min.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.validate.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.metadata.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/messages_zh.js&quot;&gt;&lt;/script&gt;\r\n第二步： 定义表单的错误输出： \r\n&lt;style type=&quot;text/css&quot;&gt;\r\n#frm label.error {\r\ncolor: Red;\r\n}\r\n&lt;/style&gt;\r\n第三步：添加错误处理方法；\r\njquery验证，需要有：\r\n1：定义验证方法 \r\n2：添加验证规则\r\n\r\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;\r\n \r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.6.1.min.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.validate.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.metadata.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/messages_zh.js&quot;&gt;&lt;/script&gt;\r\n&lt;style type=&quot;text/css&quot;&gt;\r\n    #frm label.error {\r\n        color: Red;\r\n    }\r\n&lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n \r\n$(document).ready(function(){\r\n  $(&quot;#clickme&quot;).click(function(){\r\n     alert(&quot;Hello World&quot;);\r\n });\r\n  \r\n  \r\n  \r\n  $( &quot;#frm&quot; ).validate({\r\n      rules: {\r\n          username: {\r\n              required: true,\r\n              minlength: 4,\r\n              maxlength: 20,\r\n              byteMaxLength:20,\r\n              valiEnglish:true\r\n          },\r\n          postcode: {\r\n             postcodeVal:true\r\n            },\r\n          number: {\r\n            byteMaxLength:5,\r\n            numFormat:5\r\n            },\r\n            identifier: {\r\n            sfzhValidate:true  \r\n          }\r\n             \r\n             \r\n           \r\n      },\r\n      messages: {\r\n          username: {\r\n              required: &quot;请输入用户名4--20个英文字符&quot;,\r\n              minlength: $.format(&quot;Keep typing, at least {0} characters required!&quot;),\r\n              maxlength: $.format(&quot;Whoa! Maximum {0} characters allowed!&quot;)\r\n          },\r\n          number: {\r\n              numFormat: $.format(&quot;请输入{0}数字&quot;)\r\n            }\r\n      }\r\n  });\r\n  \r\n  \r\n  \r\n jQuery.validator.addMethod(&quot;byteMaxLength&quot;, function(value,\r\n                    element, param) {\r\n                var length = value.length;\r\n                for ( var i = 0; i &lt; value.length; i++) {\r\n                    if (value.charCodeAt(i) &gt; 127) {\r\n                        length++;\r\n                    }\r\n                }\r\n                return this.optional(element) || (length &lt;= param);\r\n            }, $.validator.format(&quot;不能超过{0}个字节(一个中文字算2个字节)&quot;));\r\n  \r\n jQuery.validator.addMethod(&quot;numFormat&quot;,function(value,element,param){\r\n             return this.optional(element) || /^\\d*$/.test(value);\r\n            }\r\n            //,$.validator.format(&quot;请输入数字{0}位以内&quot;)\r\n            );\r\n             \r\n             \r\n              \r\n            //number(9,3)\r\n            jQuery.validator.addMethod(&quot;numFormat63&quot;,function(value,element){\r\n             return this.optional(element) || /^[0-9]{1,6}(\\.\\d{1,3})$/.test(value);\r\n            },$.validator.format(&quot;请输入合法数字,精度格式123456.0&quot;)\r\n            );\r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;postcodeVal&quot;,function(value,element){\r\n             return this.optional(element) || /^[0-9]\\d{5}(?!\\d)$/.test(value);\r\n            },$.validator.format(&quot;请输入合法的邮编&quot;)\r\n            );\r\n             \r\n            jQuery.validator.addMethod(&quot;numberAndLettersVal&quot;,function(value,element){\r\n             return this.optional(element) || /^[a-zA-Z0-9]+$/.test(value);\r\n            },$.validator.format(&quot;请输入字母或数字&quot;)\r\n            );\r\n             \r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;sfzhValidate&quot;,function(value,element){\r\n             return this.optional(element) || /^(\\d{14}|\\d{17})(\\d|[xX])$/.test(value);\r\n            },$.validator.format(&quot;请输入合法身份证号&quot;)\r\n            );\r\n             \r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;valiEnglish&quot;,function(value,element){\r\n             return this.optional(element) || /^[a-zA-Z ]*$/.test(value);\r\n            },$.validator.format(&quot;请输入字母或者空格&quot;)\r\n            );\r\n         \r\n \r\n});\r\n \r\n \r\n&lt;/script&gt;\r\n&lt;body&gt;\r\n&lt;form id=&quot;frm&quot; name=&quot;frm&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;label&gt;用 户 名:\r\n  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;\r\n&lt;/label&gt;\r\n &lt;p&gt;\r\n  &lt;label&gt;邮    编 :&lt;label&gt;&lt;/label&gt;&lt;/label&gt;\r\n  &lt;label&gt;\r\n  &lt;input type=&quot;text&quot; name=&quot;postcode&quot; id=&quot;postcode&quot; /&gt;\r\n  &lt;br /&gt;\r\n  &lt;/label&gt;\r\n &lt;/p&gt;\r\n &lt;p&gt;&lt;label&gt;数   字 : \r\n  &lt;input type=&quot;text&quot; name=&quot;number&quot; id=&quot;number&quot; /&gt;\r\n &lt;/label&gt;\r\n  &lt;br /&gt;&lt;label&gt;身份证号：\r\n  &lt;input type=&quot;text&quot; name=&quot;identifier&quot; id=&quot;identifier&quot; /&gt;\r\n  &lt;/label&gt;\r\n    \r\n &lt;label&gt;\r\n &lt;input type=&quot;button&quot; name=&quot;clickme&quot; id=&quot;clickme&quot; value=&quot;click me&quot; /&gt;\r\n &lt;/label&gt;\r\n &lt;/p&gt;\r\n&lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n\r\n下面讲解其中的重点方法：\r\njQuery.validator.addMethod(&quot;byteMaxLength&quot;, function(value,\r\n                   element, param) {\r\n               var length = value.length;\r\n               for ( var i = 0; i &lt; value.length; i++) {\r\n                   if (value.charCodeAt(i) &gt; 127) {\r\n                       length++;\r\n                   }\r\n               }\r\n               return this.optional(element) || (length &lt;= param);\r\n           }, $.validator.format(&quot;不能超过{0}个字节(一个中文字算2个字节)&quot;));\r\n\r\njQuery.validator.addMethod() 方法，有三个参数,\r\n第一个参数 ：   “byteMaxLength”  是定义方法名，必须保证方法名唯一，是一个identifier标志。\r\n第二个参数： 是下面这个回调（callback）函数：\r\nfunction(value, element, param) {\r\n                var length = value.length;\r\n                for ( var i = 0; i &lt; value.length; i++) {\r\n                    if (value.charCodeAt(i) &gt; 127) {\r\n                        length++;\r\n                    }\r\n                }\r\n                return this.optional(element) || (length &lt;= param);\r\n            }\r\n\r\n回调函数有三个参数：\r\n第一个：value ，是当前验证的元素的值。\r\n第二个： element  是当前被验证的元素。\r\n第三个：是传入的参数，例如： min : 5  这个参数为5，   对于本方法调用的时候，例如：byteMaxLength：10  其中10为传入参数。\r\n这个方法的方法名为： byteMaxLength  回调函数如上，\r\n回调函数的作用就是验证输入的为多少个字节，其中一个汉字代表两个字符，字符为0-127的ASCII码，其中有一句返回：\r\nreturn  this.optional(element)   这个函数调用的意思是： 用于表单输入值不为空时验证，当field为空时，即element的值为空，this.optional(element) = true, 就是说该filed不是必填项，当不填时也通过验证， 如果element的值不为空  this.optional(element) = false 就要根据  ||  后面的验证来判断返回为true 或false的目的，总结起来 this.optional(element) 就是为了说明  当前验证的 field不是必填项。\r\n第三个参数：  如下：\r\n$.validator.format(&quot;不能超过{0}个字节(一个中文字算2个字节)&quot;) \r\n\r\n这第三个参数可以直接是一个message 就是验证的提示信息，  为了显示函数的验证的信息，这个参数也可以通过创建函数jQuery.validator.format(value)来显示，其中 {0} 代表 该方法 的参数如果  方法调用如: byteMaxLength : 10  上面的输入就是 不能超过10个字节，（一个中文字算两个字节）\r\n下面看一下这段代码：\r\n$( &quot;#frm&quot; ).validate({\r\n    rules: {\r\n        username: {\r\n            required: true,\r\n            minlength: 4,\r\n            maxlength: 20,\r\n            byteMaxLength:20,\r\n            valiEnglish:true\r\n        },\r\n        postcode: {\r\n           postcodeVal:true\r\n          },\r\n        number: {\r\n          byteMaxLength:5,\r\n          numFormat:5\r\n          },\r\n          identifier: {\r\n          sfzhValidate:true  \r\n        }\r\n           \r\n           \r\n         \r\n    },\r\n    messages: {\r\n        username: {\r\n            required: &quot;请输入用户名4--20个英文字符&quot;,\r\n            minlength: $.format(&quot;Keep typing, at least {0} characters required!&quot;),\r\n            maxlength: $.format(&quot;Whoa! Maximum {0} characters allowed!&quot;)\r\n        },\r\n        number: {\r\n            numFormat: $.format(&quot;请输入{0}数字&quot;)\r\n          }\r\n    }\r\n});\r\n\r\n首先这是一个方法调用\r\n$( &quot;#frm&quot; ).validate([options]）\r\n\r\n验证选择的表单，方法的参数是可选项，可以输入0个或者键值对（key/value）\r\n这个方法是为了 处理例如：submit , focus ,  keyup , blur, click 触发验证的，对象是整个表单的元素，或者是单个元素，使用rules和 messages 定义验证的元素，使用errorClass, errorElement, wrapper, errorLabelContainer, errorContainer, showErrors, success, errorPlacement, highlight, unhighlight, and ignoreTitle去控制非法元素的错误信息显示。\r\n下面看 validate 的方法  rules();\r\n返回 第一个选择的元素的验证的规则， 有若干种方式定义验证规则。\r\nrules 方法定义了基于id的验证，\r\n username: {\r\n                           required: true,\r\n                           minlength: 4,\r\n                           maxlength: 20,\r\n                           byteMaxLength:20,\r\n                           valiEnglish:true\r\n                   }\r\n\r\n如上：其中，username为 id名， {}中为定义的验证方法，就是这个id 的都需要哪些方法验证，方法名就是上面讲到的方法；\r\n这样就定义了。\r\nmessages中定义了 ：\r\n username: {\r\n                           required: &quot;请输入用户名4--20个英文字符&quot;,\r\n                           minlength: $.format(&quot;Keep typing, at least {0} characters required!&quot;),\r\n                           maxlength: $.format(&quot;Whoa! Maximum {0} characters allowed!&quot;)\r\n                   }\r\n\r\n这个id中方法验证错误提示信息。其中可以直接输出message或者调用 $.format()方法。\r\n上面的标准格式就是：\r\nvar $params = {debug:false, rules:{}, messages:{}};\r\n $(&quot;#frm&quot;).validate($params);\r\n\r\n\r\nrules{}中定义验证规则的方法。 messages{}定义错误输出。\r\n以上为第一种方式：\r\n第二种方式：和第一种基本差不多：\r\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;\r\n \r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.6.1.min.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.validate.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.metadata.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/messages_zh.js&quot;&gt;&lt;/script&gt;\r\n&lt;style type=&quot;text/css&quot;&gt;\r\n    #frm label.error {\r\n        color: Red;\r\n    }\r\n&lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n \r\n$(document).ready(function(){\r\n  $(&quot;#clickme&quot;).click(function(){\r\n     alert(&quot;Hello World&quot;);\r\n });\r\n  \r\n  \r\n jQuery.validator.addMethod(&quot;byteMaxLength&quot;, function(value,\r\n                    element, param) {\r\n                var length = value.length;\r\n                for ( var i = 0; i &lt; value.length; i++) {\r\n                    if (value.charCodeAt(i) &gt; 127) {\r\n                        length++;\r\n                    }\r\n                }\r\n                return this.optional(element) || (length &lt;= param);\r\n            }, $.validator.format(&quot;不能超过{0}个字节(一个中文字算2个字节)&quot;));\r\n  \r\n jQuery.validator.addMethod(&quot;numFormat&quot;,function(value,element,param){\r\n             return this.optional(element) || /^\\d*$/.test(value);\r\n            },$.validator.format(&quot;请输入数字{0}位以内&quot;)\r\n            );\r\n             \r\n             \r\n              \r\n            //number(9,3)\r\n            jQuery.validator.addMethod(&quot;numFormat63&quot;,function(value,element){\r\n             return this.optional(element) || /^[0-9]{1,6}(\\.\\d{1,3})$/.test(value);\r\n            },$.validator.format(&quot;请输入合法数字,精度格式123456.0&quot;)\r\n            );\r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;postcodeVal&quot;,function(value,element){\r\n             return this.optional(element) || /^[0-9]\\d{5}(?!\\d)$/.test(value);\r\n            },$.validator.format(&quot;请输入合法的邮编&quot;)\r\n            );\r\n             \r\n            jQuery.validator.addMethod(&quot;numberAndLettersVal&quot;,function(value,element){\r\n             return this.optional(element) || /^[a-zA-Z0-9]+$/.test(value);\r\n            },$.validator.format(&quot;请输入字母或数字&quot;)\r\n            );\r\n             \r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;sfzhValidate&quot;,function(value,element){\r\n             return this.optional(element) || /^(\\d{14}|\\d{17})(\\d|[xX])$/.test(value);\r\n            },$.validator.format(&quot;请输入合法身份证号&quot;)\r\n            );\r\n             \r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;valiEnglish&quot;,function(value,element){\r\n             return this.optional(element) || /^[a-zA-Z ]*$/.test(value);\r\n            },$.validator.format(&quot;请输入字母或者空格&quot;)\r\n            );\r\n             \r\n            $(&quot;#frm&quot;).validate();\r\n         \r\n            check_infor();\r\n \r\n});\r\n \r\nfunction check_infor(){\r\n     \r\n     $(&quot;#username&quot;).attr(&quot;class&quot;,&quot;{byteMaxLength:22,valiEnglish:true}&quot;);\r\n  $(&quot;#postcode&quot;).attr(&quot;class&quot;,&quot;{byteMaxLength:6,postcodeVal:true}&quot;);\r\n   \r\n   \r\n  $(&quot;#number&quot;).attr(&quot;class&quot;,&quot;{byteMaxLength:6,numFormat:6}&quot;);\r\n  $(&quot;#identifier&quot;).attr(&quot;class&quot;,&quot;{sfzhValidate:true}&quot;);\r\n      \r\n     \r\n     \r\n    }\r\n \r\n \r\n&lt;/script&gt;\r\n&lt;body&gt;\r\n&lt;form id=&quot;frm&quot; name=&quot;frm&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;label&gt;用 户 名:\r\n  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;\r\n&lt;/label&gt;\r\n &lt;p&gt;\r\n  &lt;label&gt;邮    编 :&lt;label&gt;&lt;/label&gt;&lt;/label&gt;\r\n  &lt;label&gt;\r\n  &lt;input type=&quot;text&quot; name=&quot;postcode&quot; id=&quot;postcode&quot; /&gt;\r\n  &lt;br /&gt;\r\n  &lt;/label&gt;\r\n &lt;/p&gt;\r\n &lt;p&gt;&lt;label&gt;数   字 : \r\n  &lt;input type=&quot;text&quot; name=&quot;number&quot; id=&quot;number&quot; /&gt;\r\n &lt;/label&gt;\r\n  &lt;br /&gt;&lt;label&gt;身份证号：\r\n  &lt;input type=&quot;text&quot; name=&quot;identifier&quot; id=&quot;identifier&quot; /&gt;\r\n  &lt;/label&gt;\r\n    \r\n &lt;label&gt;\r\n &lt;input type=&quot;button&quot; name=&quot;clickme&quot; id=&quot;clickme&quot; value=&quot;click me&quot; /&gt;\r\n &lt;/label&gt;\r\n &lt;/p&gt;\r\n&lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n\r\n以上为第二种方式的代码：其中：\r\n方法定义和第一种一样：在于调用：\r\nfunction check_infor(){\r\n \r\n  $(&quot;#username&quot;).attr(&quot;class&quot;,&quot;{byteMaxLength:22,valiEnglish:true}&quot;);\r\n   $(&quot;#postcode&quot;).attr(&quot;class&quot;,&quot;{byteMaxLength:6,postcodeVal:true}&quot;);\r\n   \r\n   \r\n    $(&quot;#number&quot;).attr(&quot;class&quot;,&quot;{byteMaxLength:6,numFormat:6}&quot;);\r\n    $(&quot;#identifier&quot;).attr(&quot;class&quot;,&quot;{sfzhValidate:true}&quot;);\r\n \r\n }\r\n\r\n其中定义了一个javascript方法专门用于为form表单中需要验证的id进行验证：\r\n其中用到了.attr()  方法：这个方法有很多种参数形式 .attr(attributeName,value)方法\r\nattributeName为参数名：  value 为参数值\r\n其中下面means 是为 id为username的 元素 的 class 属性 添加值：\r\n&quot;{byteMaxLength:22,valiEnglish:true}&quot;  \r\n$(&quot;#username&quot;).attr(&quot;class&quot;,&quot;{byteMaxLength:22,valiEnglish:true}&quot;); \r\n\r\n这样该id元素就有了验证。\r\n注意： 在自定义的check_infor()调用之前 ，必须首先调用$(&quot;#frm&quot;).valudate();方法；\r\n第三种方式：\r\n\r\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;\r\n \r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.6.1.min.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.validate.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.metadata.js&quot;&gt;&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/messages_zh.js&quot;&gt;&lt;/script&gt;\r\n&lt;style type=&quot;text/css&quot;&gt;\r\n    #frm label.error {\r\n        color: Red;\r\n    }\r\n&lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n \r\n$(document).ready(function(){\r\n  $(&quot;#clickme&quot;).click(function(){\r\n     alert(&quot;Hello World&quot;);\r\n });\r\n   \r\n  jQuery.validator.addMethod(&quot;byteMaxLength&quot;, function(value,\r\n                    element, param) {\r\n                var length = value.length;\r\n                for ( var i = 0; i &lt; value.length; i++) {\r\n                    if (value.charCodeAt(i) &gt; 127) {\r\n                        length++;\r\n                    }\r\n                }\r\n                return this.optional(element) || (length &lt;= param);\r\n            }, $.validator.format(&quot;不能超过{0}个字节(一个中文字算2个字节)&quot;));\r\n  \r\n  jQuery.validator.addMethod(&quot;numFormat&quot;,function(value,element,param){\r\n             return this.optional(element) || /^\\d*$/.test(value);\r\n            },$.validator.format(&quot;请输入数字{0}位以内&quot;)\r\n            );\r\n             \r\n             \r\n              \r\n            //number(9,3)\r\n            jQuery.validator.addMethod(&quot;numFormat63&quot;,function(value,element){\r\n             return this.optional(element) || /^[0-9]{1,6}(\\.\\d{1,3})$/.test(value);\r\n            },$.validator.format(&quot;请输入合法数字,精度格式123456.0&quot;)\r\n            );\r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;postcodeVal&quot;,function(value,element){\r\n             return this.optional(element) || /^[0-9]\\d{5}(?!\\d)$/.test(value);\r\n            },$.validator.format(&quot;请输入合法的邮编&quot;)\r\n            );\r\n             \r\n            jQuery.validator.addMethod(&quot;numberAndLettersVal&quot;,function(value,element){\r\n             return this.optional(element) || /^[a-zA-Z0-9]+$/.test(value);\r\n            },$.validator.format(&quot;请输入字母或数字&quot;)\r\n            );\r\n             \r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;sfzhValidate&quot;,function(value,element){\r\n             return this.optional(element) || /^(\\d{14}|\\d{17})(\\d|[xX])$/.test(value);\r\n            },$.validator.format(&quot;请输入合法身份证号&quot;)\r\n            );\r\n             \r\n             \r\n             \r\n            jQuery.validator.addMethod(&quot;valiEnglish&quot;,function(value,element){\r\n             return this.optional(element) || /^[a-zA-Z ]*$/.test(value);\r\n            },$.validator.format(&quot;请输入字母或者空格&quot;)\r\n            );\r\n             \r\n        $(&quot;#frm&quot;).validate();\r\n        $(\'#username\').rules(\'add\', { required: true, byteMaxLength:20,valiEnglish:true});\r\n        $(\'#postcode\').rules(\'add\', { postcodeVal:true});\r\n        $(\'#number\').rules(\'add\', { byteMaxLength:5,numFormat:5});\r\n        $(\'#identifier\').rules(\'add\', { sfzhValidate:true});\r\n  \r\n         \r\n});\r\n \r\n \r\n \r\n \r\n&lt;/script&gt;\r\n&lt;body&gt;\r\n&lt;form id=&quot;frm&quot; name=&quot;frm&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;label&gt;用 户 名:\r\n  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;\r\n&lt;/label&gt;\r\n &lt;p&gt;\r\n  &lt;label&gt;邮    编 :&lt;label&gt;&lt;/label&gt;&lt;/label&gt;\r\n  &lt;label&gt;\r\n  &lt;input type=&quot;text&quot; name=&quot;postcode&quot; id=&quot;postcode&quot; /&gt;\r\n  &lt;br /&gt;\r\n  &lt;/label&gt;\r\n &lt;/p&gt;\r\n &lt;p&gt;&lt;label&gt;数   字 : \r\n  &lt;input type=&quot;text&quot; name=&quot;number&quot; id=&quot;number&quot; /&gt;\r\n &lt;/label&gt;\r\n  &lt;br /&gt;&lt;label&gt;身份证号：\r\n  &lt;input type=&quot;text&quot; name=&quot;identifier&quot; id=&quot;identifier&quot; /&gt;\r\n  &lt;/label&gt;\r\n    \r\n &lt;label&gt;\r\n &lt;input type=&quot;button&quot; name=&quot;clickme&quot; id=&quot;clickme&quot; value=&quot;click me&quot; /&gt;\r\n &lt;/label&gt;\r\n &lt;/p&gt;\r\n&lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n\r\n第三种方式与其他两种方式不同的地方就是：\r\n$(\'#username\').rules(\'add\', { required: true,  byteMaxLength:20,valiEnglish:true});\r\n                $(\'#postcode\').rules(\'add\', { postcodeVal:true});\r\n                $(\'#number\').rules(\'add\', { byteMaxLength:5,numFormat:5});\r\n                $(\'#identifier\').rules(\'add\', { sfzhValidate:true});\r\n\r\n为每一个单独的元素添加验证规则。其中调用了rules( &quot;add&quot;, rules )方法：\r\n增加验证规则为匹配的元素。\r\n注意：$(&quot;form&quot;).validate()方法必须首先被调用。\r\n这个规则也能包含一个messages-object，定义常用的messages。', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('38', 'github和git搭建博客', '如何在github搭建自己的博客\r\n\r\n1.注册github账号\r\n\r\n2.登录github\r\n\r\n3.创建一个分组\r\n\r\n4.创建一个仓库（用户名.github.io）\r\n\r\n5.设置主题\r\n\r\n6.本地创建一个分组，和github上的分组一致\r\n\r\n7.git shell 初始化(git init)\r\n\r\n8.git shell 克隆（会创建本地仓库并克隆github上的项目）\r\n\r\n9.将写好的博客复制到本地仓库里\r\n\r\n10.git shell（选中用户名.github.io文件夹 git add  *）\r\n\r\n11.git shell（git commit -m index.html)\r\n\r\n12.git shell（git push origin master)\r\n\r\n\r\ngit操作\r\n\r\n1.ssh-keygen\r\n\r\n2.继续输入3个回车\r\n\r\n3.将id_rsa.pub里面的内容复制下来，在github上的settings里面找到 SSH and GPG keys，将其粘贴到key即可，title唯一即可随便填，建议写有意义的\r\n\r\n4.ssh -T git@github.com（You\'ve successfully authenticated, but GitHub does not provide shell access）\r\n\r\n5.创建一个新的git库（在github操作）\r\n\r\n6.点击“Clone or download”,复制\r\n\r\n7.新建一个文件加，空白处右键选择“Git Bash Here”\r\n输入命令 git clone 刚才复制的SSH地址\r\n\r\n8.选择github仓库 cd wrpuser.github.io\r\n\r\n8.上传文件到github仓库\r\n\r\ngit add .\r\n\r\ngit commit -m index.html\r\n\r\ngit push origin master   推送到GitHub仓库', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('39', 'ES6基础知识', '1.变量声明const和let\r\n我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:\r\nfunctionaa() {    if(bool) {        var test = \'hello man\'    } else {        console.log(test)    }  }\r\n以上的代码实际上是：\r\nfunctionaa() {    var test // 变量提升if(bool) {        test = \'hello man\'    } else {        //此处访问test 值为undefinedconsole.log(test)    }    //此处访问test 值为undefined  }\r\n所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。\r\n接下来ES6主角登场：\r\n我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？\r\n  ● 在一个函数内部\r\n  ● 在一个代码块内部\r\n说白了 {}大括号内的代码块即为let 和 const的作用域。\r\n看以下代码：\r\nfunctionaa() {    if(bool) {       let test = \'hello man\'    } else {        //test 在此处访问不到console.log(test)    }  }\r\nlet的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。\r\n再来说说const。\r\nconstname = \'lux\'name = \'joe\'//再次赋值此时会报错\r\n说一道面试题\r\nvar funcs = []    for (var i = 0; i &lt; 10; i++) {        funcs.push(function() { console.log(i) })    }    funcs.forEach(function(func) {        func()    })\r\n这样的面试题是大家常见，很多同学一看就知道输出 10 十次\r\n但是如果我们想依次输出0到9呢？两种解决方法。直接上代码。\r\n// ES5告诉我们可以利用闭包解决这个问题var funcs = []    for (var i = 0; i &lt; 10; i++) {        func.push((function(value) {            returnfunction() {                console.log(value)            }        }(i)))    }    // es6for (let i = 0; i &lt; 10; i++) {        func.push(function() {            console.log(i)        })    }\r\n达到相同的效果，es6简洁的解决方案是不是更让你心动！！！\r\n2.模板字符串\r\nes6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。\r\n第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。\r\n//es5 var name = \'lux\'console.log(\'hello\' + name)    //es6const name = \'lux\'console.log(`hello ${name}`) //hello lux\r\n第二个用途，在ES5时我们通过反斜杠(\\)来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。\r\n// es5    var msg = &quot;Hi \\    man!    &quot;// es6consttemplate = `\r\n        hello world    \r\n`\r\n对于字符串es6当然也提供了很多厉害的方法。说几个常用的。\r\n// 1.includes：判断是否包含然后直接返回布尔值let str = \'hahay\'console.log(str.includes(\'y\')) // true// 2.repeat: 获取字符串重复n次let s = \'he\'console.log(s.repeat(3)) // \'hehehe\'//如果你带入小数, Math.floor(num) 来处理\r\n3.函数\r\n函数默认参数\r\n在ES5我们给函数定义参数默认值是怎么样？\r\nfunctionaction(num) {num = num || 200 //当传入num时，num为传入的值 //当没传入参数时，num即有了默认值200returnnum    }\r\n但细心观察的同学们肯定会发现，num传入为0的时候就是false， 此时num = 200 与我们的实际要的效果明显不一样\r\nES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。\r\nfunctionaction(num = 200){        console.log(num)    }action()//200action(300)//300\r\n箭头函数\r\nES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。\r\n箭头函数最直观的三个特点。\r\n  ● 不需要function关键字来创建函数\r\n  ● 省略return关键字\r\n  ● 继承当前上下文的 this 关键字\r\n//例如：    [1,2,3].map( x =&gt; x + 1 )//等同于：    [1,2,3].map((function(x){        return x + 1    }).bind(this))\r\n说个小细节。\r\n当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{}；例如:\r\nvar people = name =&gt; \'hello\' + name//参数name就没有括号\r\n作为参考\r\nvar people = (name, age) =&gt; {        const fullName = \'h\' + name        return fullName    }     //如果缺少()或者{}就会报错\r\n4.拓展的对象功能\r\n对象初始化简写\r\nES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如：\r\nfunction people(name, age) {        return {            name: name,            age: age        };    }\r\n键值对重名，ES6可以简写如下：\r\nfunctionpeople(name, age) {        return{            name,            age        };    }\r\nES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法：\r\nconst people = {        name: \'lux\',        getName: function() {            console.log(this.name)        }    }\r\nES6通过省略冒号与 function 关键字，将这个语法变得更简洁\r\nconst people = {        name: \'lux\',        getName () {            console.log(this.name)        }    }\r\nES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}\r\nconst obj = Object.assign({}, objA, objB)\r\n5.更方便的数据访问--解构\r\n数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程\r\nES5我们提取对象中的信息形式如下：\r\nconst people = {        name: \'lux\',        age: 20    }constname = people.nameconst age = people.age    console.log(name + \' --- \' + age)\r\n是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如\r\n//对象const people = {        name: \'lux\',        age: 20    }    const { name, age } = people    console.log(`${name} --- ${age}`)    //数组constcolor = [\'red\', \'blue\']    const [first, second] = color    console.log(first) //\'red\'    console.log(second) //\'blue\'\r\n6.Spread Operator 展开运算符\r\nES6中另外一个好玩的特性就是Spread Operator 也是三个点儿...接下来就展示一下它的用途。\r\n组装对象或者数组\r\n//数组constcolor = [\'red\', \'yellow\']    const colorful = [...color, \'green\', \'pink\']    console.log(colorful) //[red, yellow, green, pink]//对象const alp = { fist: \'a\', second: \'b\'}    const alphabets = { ...alp, third: \'c\' }    console.log(alphabets) //{ &quot;fist&quot;: &quot;a&quot;, &quot;second&quot;: &quot;b&quot;, &quot;third&quot;: &quot;c&quot;}\r\n有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项\r\n    //数组    constnumber = [1,2,3,4,5]    const [first, ...rest] = number    console.log(rest) //2,3,4,5    //对象    const user = {        username: \'lux\',        gender: \'female\',        age: 19,        address: \'peking\'    }    const { username, ...rest } = user    console.log(rest) //{&quot;address&quot;: &quot;peking&quot;, &quot;age&quot;: 19, &quot;gender&quot;: &quot;female&quot;}\r\n对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边\r\n    const first = {        a: 1,        b: 2,        c: 6,    }    const second = {        c: 3,        d: 4    }    const total = { ...first, ...second }    console.log(total) // { a: 1, b: 2, c: 3, d: 4 }\r\n7.import 和 export\r\nimport导入模块、export导出模块\r\n//全部导入import people from\'./example\'//有一种特殊情况，即允许你将整个模块当作单一对象进行导入//该模块的所有导出都会作为对象的属性存在import * as example from&quot;./example.js&quot;console.log(example.name)console.log(example.age)console.log(example.getName())//导入部分import {name, age} from\'./example\'// 导出默认, 有且只有一个默认exportdefault App// 部分导出exportclassAppextendComponent{};\r\n以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结：\r\n1.当用exportdefault people导出时，就用 import people 导入（不带大括号）2.一个文件里，有且只能有一个exportdefault。但可以有多个export。3.当用export name 时，就用import { name }导入（记得带上大括号）4.当一个文件里，既有一个exportdefault people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } 5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example\r\n8. Promise\r\n在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。\r\n说白了就是用同步的方式去写异步代码。\r\n发起异步请求\r\n    fetch(\'/api/todos\')      .then(res =&gt; res.json())      .then(data =&gt; ({ data }))      .catch(err =&gt; ({ err }));\r\n今天看到一篇关于面试题的很有意思。\r\n    setTimeout(function() {      console.log(1)    }, 0);    newPromise(functionexecutor(resolve) {      console.log(2);      for( var i=0 ; i&lt;10000 ; i++ ) {        i == 9999 &amp;&amp; resolve();      }      console.log(3);    }).then(function() {      console.log(4);    });    console.log(5);\r\nExcuse me？这个前端面试在搞事！\r\n当然以上promise的知识点，这个只是冰山一角。需要更多地去学习应用。\r\n9.Generators\r\n生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。\r\n这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。\r\nOK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。\r\n// 生成器function *createIterator() {        yield1;        yield2;        yield3;    }    // 生成器能像正规函数那样被调用，但会返回一个迭代器let iterator = createIterator();    console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3\r\n那生成器和迭代器又有什么用处呢？\r\n围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。\r\n生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。\r\n那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的\r\n    function run(taskDef) { //taskDef即一个生成器函数// 创建迭代器，让它在别处可用        let task = taskDef();        // 启动任务        let result = task.next();        // 递归使用函数来保持对 next() 的调用        function step() {            // 如果还有更多要做的if (!result.done) {                result = task.next();                step();            }        }        // 开始处理过程step();    }\r\n生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。\r\n总结\r\nES6的特性远不止于此，但对于我们日常的开发开说。这已经是够够的了。还有很多有意思的方法。比如findIndex...等等。包括用set来完成面试题常客数组去重问题。我和我的小伙伴们都惊呆了!', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('40', 'node.js应用后台守护进程管理器Forever安装和使用实例', '我们不可能直接通过node命令来管理远程站点，这样无法保证网站的可持续运行。我们用Forever来解决这个问题，它可以将NodeJS应用以后台守护进程的方式运行，我们还可以将NodeJS应用设成随系统启动而自动运行。\r\n首先，安装Forever：\r\n复制代码 代码如下:\r\n\r\nnpm install forever -gd\r\n\r\n这样Forever就安装好了，我们可以直接运行Forever命令：\r\n复制代码 代码如下:\r\n\r\nforever --help\r\nforever start app.js\r\nforever stop app.js\r\n\r\n上面命令先查看Forever帮助文件，然后运行app.js，然后停止app.js。我们要让Forever自动运行，先在/etc/init.d目录创建一个文件node，内容如下：\r\n复制代码 代码如下:\r\n\r\n#!/bin/bash\r\n#\r\n# node      Start up node server daemon\r\n#\r\n# chkconfig: 345 85 15\r\n# description: Forever for Node.js\r\n#\r\nPATH=/home/node/0.8.9/bin\r\nDEAMON=/home/ftp/1520/weizt-20120918-tKx/weizt.com/app.js\r\nLOG=/home/hosts_log\r\nPID=/tmp/forever.pid\r\ncase &quot;$1&quot; in\r\n    start)\r\n        forever start -l $LOG/forever.log -o $LOG/forever_out.log -e $LOG/forever_err.log --pidFile $PID -a $DEAMON\r\n\r\n    stop)\r\n        forever stop --pidFile $PID $DEAMON\r\n\r\n    stopall)\r\n        forever stopall --pidFile $PID\r\n\r\n    restartall)\r\n        forever restartall --pidFile $PID\r\n\r\n    reload|restart)\r\n        forever restart -l $LOG/forever.log -o $LOG/forever_out.log -e $LOG/forever_err.log --pidFile $PID -a $DEAMON\r\n\r\n    list)\r\n        forever list\r\n\r\n    *)\r\n        echo &quot;Usage: /etc.init.d/node {start|stop|restart|reload|stopall|restartall|list}&quot;\r\n        exit 1\r\n\r\nesac\r\nexit 0\r\n\r\n以上代码是我在本地虚拟机的配置，根据实际情况修改相关参数，主要是DEAMON的路径参数，赋予该文件可执行权限，并运行chkconfig添加自动运行：\r\n复制代码 代码如下:\r\n\r\nchmod 755 /etc/init.d/node\r\nchkconfig /etc/init.d/node on\r\n\r\nreboot重启系统，通过浏览器进入网站可发现，该NodeJS已经可自动运行了，剩下的工作，就是好好研究NodeJS、Express和AngularJS，做一个真正属于自己的应用！\r\n如对本文有疑问，请提交到交流社区，广大热心网友会为你解答！！ 点击进入社区', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('41', 'vue2.0与1.0的改变对比总结', '标签（空格分隔）： vue2.0\r\n  ● 在绑定原生HTML时，弃用了原来的&lt;span&gt;{{{message}}}&lt;/span&gt;，只保留了&lt;span v-html=&quot;message&quot;&gt;&lt;/span&gt;的写法。\r\n  ● 在标签里的属性中，弃用了&lt;span id=&quot;{{message}}&quot;&gt;&lt;/span&gt;的写法,只保留了&lt;span v-bind:id=&quot;message&quot;&gt;&lt;/span&gt;\r\n  ● filters只能在{{message|filter}}里使用，弃用了在指令里使用过滤器的用法，要实现相同的效果，需要在计算属性上实现。\r\n  ● 对于原生事件要加修饰符native &lt;button @click.native=&quot;handleClick&quot;&gt;点击触发 handleClick&lt;/button&gt;\r\n  ● 生命周期里删除了beforeCompile,compiled,ready,新增了beforeMount,mounted,beforUpdate,updated。\r\n  ● for循环里，取消了原有的$index，&lt;div v-for=&quot;(item,index) in dataArr&quot;&gt;需要改为ES6语法形式自己获取\r\n  ● el属性绑定的元素，限制为一个普通元素，不能再绑定在body、html等元素上。\r\n  ● 另一个特别喜欢的改变是，在自定义组件上绑定class后，对应的类名会传递到组件根元素上，如果存在同名的，则不会覆盖。这对设置组件样式非常有好处。\r\n  ● v-for 里的track-by被替换成了key,\r\n&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- content --&gt; &lt;/div&gt;\r\n  ● v-model增加了.trim,.number等后缀修饰符&lt;input v-model.trim=&quot;msg&quot;&gt;\r\n  ● Custom events can also be used to create custom inputs that work with v-model. Remember:\r\n&lt;input v-model=&quot;something&quot;&gt;\r\nis just syntactic sugar for:\r\n&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;\r\n  ● 原来的&lt;div transition=&quot;enter&quot;&gt;&lt;/div&gt;改为了标签用法&lt;transition name=&quot;enter&quot; mode=&quot;out-in&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/transition&gt;,并且可以选择过渡时的动画模式。\r\n  ● 同时过渡多个元素时，使用transition-group标签\r\n&lt;transition-group name=&quot;slide-fade&quot; tag=&quot;div&quot; appear&gt; &lt;div v-for=&quot;n in 5&quot; key=&quot;n&quot; &gt;transitiongroup&lt;/div&gt; &lt;/transition-group&gt;，appear是标识在初始化的时候执行。\r\n另外，\r\nUnlike &lt;transition&gt;, it renders an actual element: a &lt;span&gt; by default. You can change the element that’s rendered with the tag attribute.\r\nElements inside are always required to have a unique key attribute\r\n  ● 增加了directives属性自定义指令，也可以定义全局的指令：\r\n// Register a global custom directive called v-focus Vue.directive(\'focus\', { // When the bound element is inserted into the DOM... inserted: function (el) { // Focus the element el.focus() } })\r\n随着工作和学习中碰到的持续更新中···', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('42', 'gulp压缩css和js', '首先要确保pc上装有node，然后安装gulp  npm install gulp\r\n\r\n在项目中install需要的gulp插件，一般只压缩的话需要\r\nnpm install gulp-minify-css gulp-concat gulp-uglify gulp-rename del --save-dev\r\n\r\nvar gulp = require(\'gulp\'),                     //基础库\r\n    minifycss = require(\'gulp-minify-css\'),     //css压缩\r\n    concat = require(\'gulp-concat\'),            //文件重命名\r\n    uglify = require(\'gulp-uglify\'),            //js压缩\r\n    rename = require(\'gulp-rename\'),            //文件重命名\r\n    clean = require(\'gulp-clean\'),              //清空文件夹方法1\r\n    del = require(\'del\');\r\n\r\n//压缩css，在cmd中输入gulp minifycss后，执行的就是这个命令\r\n    gulp.task(\'minifycss\', function() {\r\n        return gulp.src(\'src/style.css\')      //压缩的文件\r\n            .pipe(concat(\'main.css\'))    //合并所有js到main.css\r\n            .pipe(gulp.dest(\'minified/css\'))    //输出main.css到文件夹\r\n            .pipe(rename({suffix: \'.min\'}))   //rename压缩后的文件名\r\n            .pipe(minifycss())   //执行压缩\r\n            .pipe(gulp.dest(\'minified/css\')); //输出文件夹\r\n    });\r\n\r\n\r\n    //压缩js，在cmd中输入gulp minifyjs后，执行的就是这个命令\r\n    gulp.task(\'minifyjs\', function() {\r\n        return gulp.src(\'src/common.js\') //压缩的js文件\r\n            .pipe(concat(\'main.js\'))    //合并所有js到main.js\r\n            .pipe(gulp.dest(\'minified/js\'))    //输出main.js到文件夹\r\n            .pipe(rename({suffix: \'.min\'}))   //rename压缩后的文件名\r\n            .pipe(uglify())    //压缩\r\n            .pipe(gulp.dest(\'minified/js\'));  //输出\r\n    });\r\n\r\n\r\n    //执行压缩前，先删除文件夹里的内容\r\n    gulp.task(\'clean\', function() {\r\n        del([\'minified/css\', \'minified/js\']);\r\n    });\r\n\r\n    /*gulp.task(\'clean\',function(){　　　　　　　　　　　　  \r\n        return gulp.src(\'minified\',{ read : false})       //src的第二个参数的{read:false}，是不读取文件,加快程序。\r\n            .pipe(clean());\r\n    })*/\r\n\r\n\r\n    //默认命令，在cmd中输入gulp后，执行的就是这个命令\r\n    gulp.task(\'default\', [\'clean\', \'minifycss\', \'minifyjs\']);', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('43', 'LESS 语法', '\r\nLESS 做为 CSS 的一种形式的扩展，它并没有阉割 CSS 的功能，而是在现有的 CSS 语法上，添加了很多额外的功能，所以学习 LESS 是一件轻而易举的事情，果断学习之！\r\n\r\n变量\r\n\r\n很容易理解:\r\n\r\n@nice-blue: #5B83AD;\r\n@light-blue: @nice-blue + #111;\r\n\r\n#header { color: @light-blue; }\r\n输出:\r\n\r\n#header { color: #6c94be; }\r\n甚至可以用变量名定义为变量:\r\n\r\n@fnord: &quot;I am fnord.&quot;;\r\n@var: \'fnord\';\r\ncontent: @@var;\r\n解析后:\r\n\r\ncontent: &quot;I am fnord.&quot;;\r\n请注意 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次.\r\n\r\n混合\r\n\r\n在 LESS 中我们可以定义一些通用的属性集为一个class，然后在另一个class中去调用这些属性. 下面有这样一个class:\r\n\r\n.bordered {\r\n  border-top: dotted 1px black;\r\n  border-bottom: solid 2px black;\r\n}\r\n那如果我们现在需要在其他class中引入那些通用的属性集，那么我们只需要在任何class中像下面这样调用就可以了:\r\n\r\n#menu a {\r\n  color: #111;\r\n  .bordered;\r\n}\r\n.post a {\r\n  color: red;\r\n  .bordered;\r\n}\r\n.bordered class里面的属性样式都会在 #menu a 和 .post a中体现出来:\r\n\r\n#menu a {\r\n  color: #111;\r\n  border-top: dotted 1px black;\r\n  border-bottom: solid 2px black;\r\n}\r\n.post a {\r\n  color: red;\r\n  border-top: dotted 1px black;\r\n  border-bottom: solid 2px black;\r\n}\r\n任何 CSS class, id 或者 元素 属性集都可以以同样的方式引入.\r\n\r\n带参数混合\r\n\r\n在 LESS 中，你还可以像函数一样定义一个带参数的属性集合:\r\n\r\n.border-radius (@radius) {\r\n  border-radius: @radius;\r\n  -moz-border-radius: @radius;\r\n  -webkit-border-radius: @radius;\r\n}\r\n然后在其他class中像这样调用它:\r\n\r\n#header {\r\n  .border-radius(4px);\r\n}\r\n.button {\r\n  .border-radius(6px);  \r\n}\r\n我们还可以像这样给参数设置默认值:\r\n\r\n.border-radius (@radius: 5px) {\r\n  border-radius: @radius;\r\n  -moz-border-radius: @radius;\r\n  -webkit-border-radius: @radius;\r\n}\r\n所以现在如果我们像这样调用它的话:\r\n\r\n#header {\r\n  .border-radius;  \r\n}\r\nradius的值就会是5px.\r\n\r\n你也可以定义不带参数属性集合,如果你想隐藏这个属性集合，不让它暴露到CSS中去，但是你还想在其他的属性集合中引用，你会发现这个方法非常的好用:\r\n\r\n.wrap () {\r\n  text-wrap: wrap;\r\n  white-space: pre-wrap;\r\n  white-space: -moz-pre-wrap;\r\n  word-wrap: break-word;\r\n}\r\n\r\npre { .wrap }\r\n输出:\r\n\r\npre {\r\n  text-wrap: wrap;\r\n  white-space: pre-wrap;\r\n  white-space: -moz-pre-wrap;\r\n  word-wrap: break-word;\r\n}\r\n@arguments 变量\r\n\r\n@arguments包含了所有传递进来的参数. 如果你不想单独处理每一个参数的话就可以像这样写:\r\n\r\n.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {\r\n  box-shadow: @arguments;\r\n  -moz-box-shadow: @arguments;\r\n  -webkit-box-shadow: @arguments;\r\n}\r\n.box-shadow(2px, 5px);\r\n将会输出:\r\n\r\n  box-shadow: 2px 5px 1px #000;\r\n  -moz-box-shadow: 2px 5px 1px #000;\r\n  -webkit-box-shadow: 2px 5px 1px #000;\r\n模式匹配和导引表达式\r\n\r\n有些情况下，我们想根据传入的参数来改变混合的默认呈现，比如下面这个例子：\r\n\r\n.mixin (@s, @color) { ... }\r\n\r\n.class {\r\n  .mixin(@switch, #888);\r\n}\r\n如果想让.mixin根据不同的@switch值而表现各异，如下这般设置：\r\n\r\n.mixin (dark, @color) {\r\n  color: darken(@color, 10%);\r\n}\r\n.mixin (light, @color) {\r\n  color: lighten(@color, 10%);\r\n}\r\n.mixin (@_, @color) {\r\n  display: block;\r\n}\r\n现在，如果运行:\r\n\r\n@switch: light;\r\n\r\n.class {\r\n  .mixin(@switch, #888);\r\n}\r\n就会得到下列CSS:\r\n\r\n.class {\r\n  color: #a2a2a2;\r\n  display: block;\r\n}\r\n如上，.mixin就会得到传入颜色的浅色。如果@switch设为dark，就会得到深色。\r\n\r\n具体实现如下：\r\n\r\n第一个混合定义并未被匹配，因为它只接受dark做为首参\r\n第二个混合定义被成功匹配，因为它只接受light\r\n第三个混合定义被成功匹配，因为它接受任意值\r\n只有被匹配的混合才会被使用。变量可以匹配任意的传入值，而变量以外的固定值就仅仅匹配与其相等的传入值。\r\n\r\n我们也可以匹配多个参数：\r\n\r\n.mixin (@a) {\r\n  color: @a;\r\n}\r\n.mixin (@a, @b) {\r\n  color: fade(@a, @b);\r\n}\r\nNow if we call .mixin with a single argument, we will get the output of the first definition, but if we call it with two arguments, we will get the second definition, namely @a faded to @b.\r\n\r\n引导\r\n\r\n当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。\r\n\r\n为了尽可能地保留CSS的可声明性，LESS通过导引混合而非if/else语句来实现条件判断，因为前者已在@media query特性中被定义。\r\n\r\n以此例做为开始：\r\n\r\n.mixin (@a) when (lightness(@a) &gt;= 50%) {\r\n  background-color: black;\r\n}\r\n.mixin (@a) when (lightness(@a) &lt; 50%) {\r\n  background-color: white;\r\n}\r\n.mixin (@a) {\r\n  color: @a;\r\n}\r\nwhen关键字用以定义一个导引序列(此例只有一个导引)。接下来我们运行下列代码：\r\n\r\n.class1 { .mixin(#ddd) }\r\n.class2 { .mixin(#555) }\r\n就会得到：\r\n\r\n.class1 {\r\n  background-color: black;\r\n  color: #ddd;\r\n}\r\n.class2 {\r\n  background-color: white;\r\n  color: #555;\r\n}\r\n导引中可用的全部比较运算有： &gt; &gt;= = =&lt; &lt;。此外，关键字true只表示布尔真值，下面两个混合是相同的：\r\n\r\n.truth (@a) when (@a) { ... }\r\n.truth (@a) when (@a = true) { ... }\r\n除去关键字true以外的值都被视示布尔假：\r\n\r\n.class {\r\n  .truth(40); // Will not match any of the above definitions.\r\n}\r\n导引序列使用逗号‘,’—分割，当且仅当所有条件都符合时，才会被视为匹配成功。\r\n\r\n.mixin (@a) when (@a &gt; 10), (@a &lt; -10) { ... }\r\n导引可以无参数，也可以对参数进行比较运算：\r\n\r\n@media: mobile;\r\n\r\n.mixin (@a) when (@media = mobile) { ... }\r\n.mixin (@a) when (@media = desktop) { ... }\r\n\r\n.max (@a, @b) when (@a &gt; @b) { width: @a }\r\n.max (@a, @b) when (@a &lt; @b) { width: @b }\r\n最后，如果想基于值的类型进行匹配，我们就可以使用is*函式：\r\n\r\n.mixin (@a, @b: 0) when (isnumber(@b)) { ... }\r\n.mixin (@a, @b: black) when (iscolor(@b)) { ... }\r\n下面就是常见的检测函式：\r\n\r\niscolor\r\nisnumber\r\nisstring\r\niskeyword\r\nisurl\r\n如果你想判断一个值是纯数字，还是某个单位量，可以使用下列函式：\r\n\r\nispixel\r\nispercentage\r\nisem\r\n最后再补充一点，在导引序列中可以使用and关键字实现与条件：\r\n\r\n.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) { ... }\r\n使用not关键字实现或条件\r\n\r\n.mixin (@b) when not (@b &gt; 0) { ... }\r\n嵌套规则\r\n\r\nLESS 可以让我们以嵌套的方式编写层叠样式. 让我们先看下下面这段 CSS:\r\n\r\n#header { color: black; }\r\n#header .navigation {\r\n  font-size: 12px;\r\n}\r\n#header .logo { \r\n  width: 300px; \r\n}\r\n#header .logo:hover {\r\n  text-decoration: none;\r\n}\r\n在 LESS 中, 我们就可以这样写:\r\n\r\n#header {\r\n  color: black;\r\n\r\n  .navigation {\r\n    font-size: 12px;\r\n  }\r\n  .logo {\r\n    width: 300px;\r\n    &amp;:hover { text-decoration: none }\r\n  }\r\n}\r\n或者这样写:\r\n\r\n#header        { color: black;\r\n  .navigation  { font-size: 12px }\r\n  .logo        { width: 300px;\r\n    &amp;:hover    { text-decoration: none }\r\n  }\r\n}\r\n代码更简洁了，而且感觉跟DOM结构格式有点像.\r\n\r\n注意 &amp; 符号的使用—如果你想写串联选择器，而不是写后代选择器，就可以用到&amp;了. 这点对伪类尤其有用如 :hover 和 :focus.\r\n\r\n例如:\r\n\r\n.bordered {\r\n  &amp;.float {\r\n    float: left; \r\n  }\r\n  .top {\r\n    margin: 5px; \r\n  }\r\n}\r\n会输出\r\n\r\n.bordered.float {\r\n  float: left;  \r\n}\r\n.bordered .top {\r\n  margin: 5px;\r\n}\r\n运算\r\n\r\n任何数字、颜色或者变量都可以参与运算. 来看一组例子:\r\n\r\n@base: 5%;\r\n@filler: @base * 2;\r\n@other: @base + @filler;\r\n\r\ncolor: #888 / 4;\r\nbackground-color: @base-color + #111;\r\nheight: 100% / 2 + @filler;\r\nLESS 的运算已经超出了我们的期望，它能够分辨出颜色和单位。如果像下面这样单位运算的话:\r\n\r\n@var: 1px + 5;\r\nLESS 会输出 6px.\r\n\r\n括号也同样允许使用:\r\n\r\nwidth: (@var + 5) * 2;\r\n并且可以在复合属性中进行运算:\r\n\r\nborder: (@width * 2) solid black;\r\nColor 函数\r\n\r\nLESS 提供了一系列的颜色运算函数. 颜色会先被转化成 HSL 色彩空间, 然后在通道级别操作:\r\n\r\n\r\nlighten(@color, 10%);     // return a color which is 10% *lighter* than @color\r\ndarken(@color, 10%);      // return a color which is 10% *darker* than @color\r\n\r\nsaturate(@color, 10%);    // return a color 10% *more* saturated than @color\r\ndesaturate(@color, 10%);  // return a color 10% *less* saturated than @color\r\n\r\nfadein(@color, 10%);      // return a color 10% *less* transparent than @color\r\nfadeout(@color, 10%);     // return a color 10% *more* transparent than @color\r\nfade(@color, 50%);        // return @color with 50% transparency\r\n\r\nspin(@color, 10);         // return a color with a 10 degree larger in hue than @color\r\nspin(@color, -10);        // return a color with a 10 degree smaller hue than @color\r\n\r\nmix(@color1, @color2);    // return a mix of @color1 and @color2\r\n使用起来相当简单:\r\n\r\n@base: #f04615;\r\n\r\n.class {\r\n  color: saturate(@base, 5%);\r\n  background-color: lighten(spin(@base, 8), 25%);\r\n}\r\n你还可以提取颜色信息:\r\n\r\nhue(@color);        // returns the `hue` channel of @color\r\nsaturation(@color); // returns the `saturation` channel of @color\r\nlightness(@color);  // returns the \'lightness\' channel of @color\r\n如果你想在一种颜色的通道上创建另一种颜色，这些函数就显得那么的好用，例如:\r\n\r\n@new: hsl(hue(@old), 45%, 90%);\r\n@new 将会保持 @old的 色调, 但是具有不同的饱和度和亮度.\r\n\r\nMath 函数\r\n\r\nLESS提供了一组方便的数学函数，你可以使用它们处理一些数字类型的值:\r\n\r\nround(1.67); // returns `2`\r\nceil(2.4);   // returns `3`\r\nfloor(2.6);  // returns `2`\r\n如果你想将一个值转化为百分比，你可以使用percentage 函数:\r\n\r\npercentage(0.5); // returns `50%`\r\n命名空间\r\n\r\n有时候，你可能为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 你可以像下面这样在#bundle中定义一些属性集之后可以重复使用:\r\n\r\n#bundle {\r\n  .button () {\r\n    display: block;\r\n    border: 1px solid black;\r\n    background-color: grey;\r\n    &amp;:hover { background-color: white }\r\n  }\r\n  .tab { ... }\r\n  .citation { ... }\r\n}\r\n你只需要在 #header a中像这样引入 .button:\r\n\r\n#header a {\r\n  color: orange;\r\n  #bundle &gt; .button;\r\n}\r\n作用域\r\n\r\nLESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止.\r\n\r\n@var: red;\r\n\r\n#page {\r\n  @var: white;\r\n  #header {\r\n    color: @var; // white\r\n  }\r\n}\r\n\r\n#footer {\r\n  color: @var; // red  \r\n}\r\n注释\r\n\r\nCSS 形式的注释在 LESS 中是依然保留的:\r\n\r\n/* Hello, I\'m a CSS-style comment */\r\n.class { color: black }\r\nLESS 同样也支持双斜线的注释, 但是编译成 CSS 的时候自动过滤掉:\r\n\r\n// Hi, I\'m a silent comment, I won\'t show up in your CSS\r\n.class { color: white }\r\nImporting\r\n\r\n你可以在main文件中通过下面的形势引入 .less 文件, .less 后缀可带可不带:\r\n\r\n@import &quot;lib.less&quot;;\r\n@import &quot;lib&quot;;\r\n如果你想导入一个CSS文件而且不想LESS对它进行处理，只需要使用.css后缀就可以:\r\n\r\n@import &quot;lib.css&quot;;\r\n这样LESS就会跳过它不去处理它.\r\n\r\n字符串插值\r\n\r\n变量可以用类似ruby和php的方式嵌入到字符串中，像@{name}这样的结构:\r\n\r\n@base-url: &quot;http://assets.fnord.com&quot;;\r\nbackground-image: url(&quot;@{base-url}/images/bg.png&quot;);\r\n避免编译\r\n\r\n有时候我们需要输出一些不正确的CSS语法或者使用一些 LESS不认识的专有语法.\r\n\r\n要输出这样的值我们可以在字符串前加上一个 ~, 例如:\r\n\r\n\r\n.class {\r\n  filter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;\r\n}\r\n我们可以将要避免编译的值用 “”包含起来，输出结果为:\r\n\r\n\r\n.class {\r\n  filter: ms:alwaysHasItsOwnSyntax.For.Stuff();\r\n}\r\nJavaScript 表达式\r\n\r\nJavaScript 表达式也可以在.less 文件中使用. 可以通过反引号的方式使用:\r\n\r\n@var: `&quot;hello&quot;.toUpperCase() + \'!\'`;\r\n输出:\r\n\r\n@var: &quot;HELLO!&quot;;\r\n注意你也可以同时使用字符串插值和避免编译:\r\n\r\n@str: &quot;hello&quot;;\r\n@var: ~`&quot;@{str}&quot;.toUpperCase() + \'!\'`;\r\n输出:\r\n\r\n@var: HELLO!;\r\n它也可以访问JavaScript环境:\r\n\r\n@height: `document.body.clientHeight`;\r\n如果你想将一个JavaScript字符串解析成16进制的颜色值, 你可以使用 color 函数:\r\n\r\n@color: color(`window.colors.baseColor`);\r\n@darkcolor: darken(@color, 10%);', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('44', '初识Vue--MVVM框架', 'Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js。\r\n本文摘自：http://www.cnblogs.com/keepfool/p/5619070.html\r\n\r\n如果你之前已经习惯了用jQuery操作DOM，学习Vue.js时请先抛开手动操作DOM的思维，因为Vue.js是数据驱动的，你无需手动操作DOM。它通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦你创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新。\r\n\r\n当然了，在使用Vue.js时，你也可以结合其他库一起使用，比如jQuery。\r\n\r\n本文的Demo和源代码已放到GitHub，如果您觉得本篇内容不错，请点个赞，或在GitHub上加个星星！\r\n\r\nv-for Demo v-bind Demo Page Demo GitHub Source\r\n\r\nMVVM模式\r\n下图不仅概括了MVVM模式（Model-View-ViewModel），还描述了在Vue.js中ViewModel是如何和View以及Model进行交互的。\r\n\r\nViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。\r\n\r\n当创建了ViewModel后，双向绑定是如何达成的呢？\r\n\r\n首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。\r\n从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；\r\n从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。\r\n\r\nHello World示例\r\n了解一门语言，或者学习一门新技术，编写Hello World示例是我们的必经之路。\r\n这段代码在画面上输出&quot;Hello World!&quot;。\r\n\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n    &lt;head&gt;\r\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n        &lt;title&gt;&lt;/title&gt;\r\n    &lt;/head&gt;\r\n\r\n    &lt;body&gt;\r\n        &lt;!--这是我们的View--&gt;\r\n        &lt;div id=&quot;app&quot;&gt;\r\n            {{ message }}\r\n        &lt;/div&gt;\r\n    &lt;/body&gt;\r\n    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script&gt;\r\n        // 这是我们的Model\r\n        var exampleData = {\r\n            message: \'Hello World!\'\r\n        }\r\n\r\n        // 创建一个 Vue 实例或 &quot;ViewModel&quot;\r\n        // 它连接 View 与 Model\r\n        new Vue({\r\n            el: \'#app\',\r\n            data: exampleData\r\n        })\r\n    &lt;/script&gt;\r\n&lt;/html&gt;', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('45', 'Webpack入门', '本文写作时所用的webpack版本为1.版，与webpack2.在部分语法上存在不同。请见谅\r\n\r\n写在前面的话\r\n\r\n阅读本文之前，先看下面这个webpack的配置文件，如果每一项你都懂，那本文能带给你的收获也许就比较有限，你可以快速浏览或直接跳过；如果你和十天前的我一样，对很多选项存在着疑惑，那花一段时间慢慢阅读本文，你的疑惑一定一个一个都会消失；如果你以前没怎么接触过Webpack，而你又你对webpack感兴趣，那么动手跟着本文中那个贯穿始终的例子写一次，写完以后你会发现你已明明白白的走进了Webpack的大门。\r\n//一个常见的Webpack配置文件\r\nvar webpack = require(\'webpack\');\r\nvar HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\nvar ExtractTextPlugin = require(\'extract-text-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  entry: __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/build&quot;,\r\n    filename: &quot;[name]-[hash].js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        loader: ExtractTextPlugin.extract(\'style\', \'css?modules!postcss\')\r\n      }\r\n    ]\r\n  },\r\n  postcss: [\r\n    require(\'autoprefixer\')\r\n  ],\r\n\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: __dirname + &quot;/app/index.tmpl.html&quot;\r\n    }),\r\n    new webpack.optimize.OccurenceOrderPlugin(),\r\n    new webpack.optimize.UglifyJsPlugin(),\r\n    new ExtractTextPlugin(&quot;[name]-[hash].css&quot;)\r\n  ]\r\n}\r\n什么是WebPack，为什么要使用它？\r\n\r\n为什要使用WebPack\r\n\r\n现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法\r\n\r\n模块化，让我们可以把复杂的程序细化为小的文件;\r\n类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；\r\nScss，less等CSS预处理器\r\n...\r\n这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。\r\n\r\n什么是Webpack\r\n\r\nWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\r\n\r\nWebPack和Grunt以及Gulp相比有什么特性\r\n\r\n其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。\r\n\r\nGrunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。\r\n\r\n\r\nGrunt和Gulp的工作流程\r\nWebpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。\r\n\r\n\r\nWebpack工作方式\r\n如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。\r\n\r\n开始使用Webpack\r\n\r\n初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。\r\n\r\n安装\r\n\r\nWebpack可以使用npm安装，新建一个空的练习文件夹（此处命名为webpack sample progect），在终端中转到该文件夹后执行下述指令就可以完成安装。\r\n\r\n//全局安装\r\nnpm install -g webpack\r\n//安装到你的项目目录\r\nnpm install --save-dev webpack\r\n正式使用Webpack前的准备\r\n\r\n在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件\r\nnpm init\r\n输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。\r\n\r\npackage.json文件已经就绪，我们在本项目中安装Webpack作为依赖包\r\n\r\n// 安装Webpack\r\nnpm install --save-dev webpack\r\n回到之前的空文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中，此时项目结构如下图所示\r\n\r\n\r\n项目结构\r\nindex.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js）\r\n\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html lang=&quot;en&quot;&gt;\r\n  &lt;head&gt;\r\n    &lt;meta charset=&quot;utf-8&quot;&gt;\r\n    &lt;title&gt;Webpack Sample Project&lt;/title&gt;\r\n  &lt;/head&gt;\r\n  &lt;body&gt;\r\n    &lt;div id=\'root\'&gt;\r\n    &lt;/div&gt;\r\n    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;\r\nGreeter.js只包括一个用来返回包含问候信息的html元素的函数。\r\n\r\n// Greeter.js\r\nmodule.exports = function() {\r\n  var greet = document.createElement(\'div\');\r\n  greet.textContent = &quot;Hi there and greetings!&quot;;\r\n  return greet;\r\n};\r\nmain.js用来把Greeter模块返回的节点插入页面。\r\n\r\n//main.js \r\nvar greeter = require(\'./Greeter.js\');\r\ndocument.getElementById(\'root\').appendChild(greeter());\r\n正式使用Webpack\r\n\r\nwebpack可以在终端中使用，其最基础的命令是\r\n\r\nwebpack {entry file/入口文件} {destination for bundled file/存放bundle.js的地方}\r\n只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果你的webpack没有进行全局安装，那么当你在终端中使用此命令时，需要额外指定其在node_modules中的地址，继续上面的例子，在终端中属于如下命令\r\n\r\n//webpack非全局安装的情况\r\nnode_modules/.bin/webpack app/main.js public/bundle.js\r\n结果如下\r\n\r\n\r\ntermialResult1\r\n\r\n可以看出webpack同时编译了main.js 和Greeter,js,现在打开index.html,可以看到如下结果\r\n\r\n\r\nhtmlResult1\r\n\r\n有没有很激动，已经成功的使用Webpack打包了一个文件了。不过如果在终端中进行复杂的操作，还是不太方便且容易出错的，接下来看看Webpack的另一种使用方法。\r\n\r\n通过配置文件来使用Webpack\r\n\r\nWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。\r\n\r\n还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。\r\n\r\nmodule.exports = {\r\n  entry:  __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件\r\n  output: {\r\n    path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方\r\n    filename: &quot;bundle.js&quot;//打包后输出文件的文件名\r\n  }\r\n}\r\n注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。\r\n现在如果你需要打包文件只需要在终端里你运行webpack(非全局安装需使用node_modules/.bin/webpack)命令就可以了，这条命令会自动参考webpack.config.js文件中的配置选项打包你的项目，输出结果如下\r\n\r\n\r\nwebpack\r\n\r\n又学会了一种使用Webpack的方法，而且不用管那烦人的命令行参数了，有没有感觉很爽。有没有想过如果可以连webpack(非全局安装需使用node_modules/.bin/webpack)这条命令都可以不用，那种感觉会不会更爽~，继续看下文。\r\n\r\n更快捷的执行打包任务\r\n\r\n执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下。\r\n\r\n{\r\n  &quot;name&quot;: &quot;webpack-sample-project&quot;,\r\n  &quot;version&quot;: &quot;1.0.0&quot;,\r\n  &quot;description&quot;: &quot;Sample webpack project&quot;,\r\n  &quot;scripts&quot;: {\r\n    &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令\r\n  },\r\n  &quot;author&quot;: &quot;zhang&quot;,\r\n  &quot;license&quot;: &quot;ISC&quot;,\r\n  &quot;devDependencies&quot;: {\r\n    &quot;webpack&quot;: &quot;^1.12.9&quot;\r\n  }\r\n}\r\n注：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。\r\nnpm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，以下是执行npm start后命令行的输出显示\r\n\r\n\r\nnpmStartTermialResult\r\n现在只需要使用npm start就可以打包文件了，有没有觉得webpack也不过如此嘛，不过不要太小瞧Webpack，其强大的功能包含在其一系列可供配置的选项中，我们一项项来看。\r\n\r\nWebpack的强大功能\r\n\r\n生成Source Maps（使调试更容易）\r\n\r\n开发总是离不开调试，如果可以更加方便的调试当然就能提高开发效率，不过打包后的文件有时候你是不容易找到出错了的地方对应的源代码的位置的，Source Maps就是来帮我们解决这个问题的。\r\n通过简单的配置后，Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。\r\n\r\n在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下：\r\n\r\ndevtool选项	配置结果\r\nsource-map	在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；\r\ncheap-module-source-map	在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；\r\neval-source-map	使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；\r\ncheap-module-eval-source-map	这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；\r\n正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。\r\n\r\n在学习阶段以及在小到中性的项目上，eval-source-map是一个很好的选项，不过记得只在开发阶段使用它，继续上面的例子，进行如下配置\r\n\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',//配置生成Source Maps，选择合适的选项\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/public&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  }\r\n}\r\ncheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本是使用。\r\n使用webpack构建本地服务器\r\n\r\n想不想让你的浏览器监测你的代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖\r\n\r\nnpm install --save-dev webpack-dev-server\r\ndevserver作为webpack配置选项中的一项，具有以下配置选项\r\n\r\ndevserver配置选项	功能描述\r\ncontentBase	默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public&quot;目录）\r\nport	设置默认监听端口，如果省略，默认为”8080“\r\ninline	设置为true，当源文件改变时会自动刷新页面\r\ncolors	设置为true，使终端输出的文件为彩色的\r\nhistoryApiFallback	在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html\r\n继续把这些命令加到webpack的配置文件中，现在的配置文件如下所示\r\n\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/public&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  devServer: {\r\n    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录\r\n    colors: true,//终端中输出结果为彩色\r\n    historyApiFallback: true,//不跳转\r\n    inline: true//实时刷新\r\n  } \r\n}\r\nLoaders\r\n\r\n鼎鼎大名的Loaders登场了！\r\n\r\nLoaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。\r\n\r\nLoaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面：\r\n\r\ntest：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）\r\nloader：loader的名称（必须）\r\ninclude/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；\r\nquery：为loaders提供额外的设置选项（可选）\r\n继续上面的例子，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，配置方法如下\r\n\r\n//安装可以装换JSON的loader\r\nnpm install --save-dev json-loader\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/public&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {//在配置文件里添加JSON loader\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      }\r\n    ]\r\n  },\r\n\r\n  devServer: {\r\n    contentBase: &quot;./public&quot;,\r\n    colors: true,\r\n    historyApiFallback: true,\r\n    inline: true\r\n  }\r\n}\r\n创建带有问候信息的JSON文件(命名为config.json)\r\n\r\n//config.json\r\n{\r\n  &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;\r\n}\r\n更新后的Greeter.js\r\n\r\nvar config = require(\'./config.json\');\r\n\r\nmodule.exports = function() {\r\n  var greet = document.createElement(\'div\');\r\n  greet.textContent = config.greetText;\r\n  return greet;\r\n};\r\nLoaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。\r\n\r\nBabel\r\n\r\nBabel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的：\r\n\r\n下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持；\r\n使用基于JavaScript进行了拓展的语言，比如React的JSX\r\nBabel的安装与配置\r\n\r\nBabel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。\r\n\r\n我们先来一次性安装这些依赖包\r\n\r\n// npm一次性安装多个依赖模块，模块之间用空格隔开\r\nnpm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react\r\n在webpack中配置Babel的方法如下\r\n\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/public&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\',//在webpack的module部分的loaders里进行配置即可\r\n        query: {\r\n          presets: [\'es2015\',\'react\']\r\n        }\r\n      }\r\n    ]\r\n  },\r\n\r\n  devServer: {\r\n    contentBase: &quot;./public&quot;,\r\n    colors: true,\r\n    historyApiFallback: true,\r\n    inline: true\r\n  }\r\n}\r\n现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM\r\n\r\nnpm install --save react react-dom\r\n使用ES6的语法，更新Greeter.js并返回一个React组件\r\n\r\n//Greeter,js\r\nimport React, {Component} from \'react\'\r\nimport config from \'./config.json\';\r\n\r\nclass Greeter extends Component{\r\n  render() {\r\n    return (\r\n      &lt;div&gt;\r\n        {config.greetText}\r\n      &lt;/div&gt;\r\n    );\r\n  }\r\n}\r\n\r\nexport default Greeter\r\n使用ES6的模块定义和渲染Greeter模块\r\n\r\nimport React from \'react\';\r\nimport {render} from \'react-dom\';\r\nimport Greeter from \'./Greeter\';\r\n\r\nrender(&lt;Greeter /&gt;, document.getElementById(\'root\'));\r\nBabel的配置选项\r\n\r\nBabel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 &quot;.babelrc&quot; 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：\r\n\r\n// webpack.config.js\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/public&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      }\r\n    ]\r\n  },\r\n\r\n  devServer: {...} // Omitted for brevity\r\n}\r\n//.babelrc\r\n{\r\n  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]\r\n}\r\n到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。\r\n\r\n一切皆模块\r\n\r\nWebpack有一个不可不说的优点，它把所有的文件都可以当做模块处理，包括你的JavaScript代码，也包括CSS和fonts以及图片等等等，只有通过合适的loaders，它们都可以被当做模块被处理。\r\n\r\nCSS\r\n\r\nwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。\r\n\r\n继续上面的例子\r\n\r\n//安装\r\nnpm install --save-dev style-loader css-loader\r\n//使用\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/build&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        loader: \'style!css\'//添加对样式表的处理\r\n      }\r\n    ]\r\n  },\r\n\r\n  devServer: {...}\r\n}\r\n注：感叹号的作用在于使同一文件能够使用不同类型的loader\r\n接下来，在app文件夹里创建一个名字为&quot;main.css&quot;的文件，对一些元素设置样式\r\n\r\nhtml {\r\n  box-sizing: border-box;\r\n  -ms-text-size-adjust: 100%;\r\n  -webkit-text-size-adjust: 100%;\r\n}\r\n\r\n*, *:before, *:after {\r\n  box-sizing: inherit;\r\n}\r\n\r\nbody {\r\n  margin: 0;\r\n  font-family: \'Helvetica Neue\', Helvetica, Arial, sans-serif;\r\n}\r\n\r\nh1, h2, h3, h4, h5, h6, p, ul {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下\r\n\r\n//main.js\r\nimport React from \'react\';\r\nimport {render} from \'react-dom\';\r\nimport Greeter from \'./Greeter\';\r\n\r\nimport \'./main.css\';//使用require导入css文件\r\n\r\nrender(&lt;Greeter /&gt;, document.getElementById(\'root\'));\r\n通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。\r\n不过这也只是webpack把css当做模块而已，咱们继续看看一个真的CSS模块的实践。\r\nCSS module\r\n\r\n在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，且基于优化工具，依赖管理和加载管理可以自动完成。\r\n不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧是巨大且充满了全局类名，这使得维护和修改都非常困难和复杂。\r\n\r\n最近有一个叫做 CSS modules 的技术就意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules“传递都所需要的地方，然后就可以直接把CSS的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。具体的代码如下\r\n\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {...},\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        loader: \'style!css?modules\'//跟前面相比就在后面加上了?modules\r\n      }\r\n    ]\r\n  },\r\n\r\n  devServer: {...}\r\n}\r\n创建一个Greeter.css文件\r\n\r\n.root {\r\n  background-color: #eee;\r\n  padding: 10px;\r\n  border: 3px solid #ccc;\r\n}\r\n导入.root到Greeter.js中\r\n\r\nimport React, {Component} from \'react\';\r\nimport config from \'./config.json\';\r\nimport styles from \'./Greeter.css\';//导入\r\n\r\nclass Greeter extends Component{\r\n  render() {\r\n    return (\r\n      &lt;div className={styles.root}&gt;//添加类名\r\n        {config.greetText}\r\n      &lt;/div&gt;\r\n    );\r\n  }\r\n}\r\n\r\nexport default Greeter\r\n放心使用把，相同的类名也不会造成不同组件之间的污染。\r\nCSS modules 也是一个很大的主题，有兴趣的话可以去官方文档查看更多消息\r\n\r\nCSS预处理器\r\n\r\nSass 和 Less之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句，\r\n你现在可能都已经熟悉了，在webpack里使用相关loaders进行配置就可以使用了，以下是常用的CSS 处理loaders\r\n\r\nLess Loader\r\nSass Loader\r\nStylus Loader\r\n不过其实也存在一个CSS的处理平台-PostCSS，它可以帮助你的CSS实现更多的功能，在其CSS官方文档可了解更多相关知识。\r\n\r\n举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。\r\n\r\n首先安装postcss-loader 和 autoprefixer（自动添加前缀的插件）\r\n\r\nnpm install --save-dev postcss-loader autoprefixer\r\n接下来，在webpack配置文件中进行设置，只需要新建一个postcss关键字，并在里面申明依赖的插件，如下，现在你写的css会自动根据Can i use里的数据添加不同前缀了。\r\n\r\n//webpack配置文件\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n  entry: __dirname + &quot;/app/main.js&quot;,\r\n  output: {...},\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        loader: \'style!css?modules!postcss\'\r\n      }\r\n    ]\r\n  },\r\n\r\n  postcss: [\r\n    require(\'autoprefixer\')//调用autoprefixer插件\r\n  ],\r\n\r\n  devServer: {...}\r\n}\r\n到现在，本文已经涉及到处理JS的Babel和处理CSS的PostCSS，它们其实也是两个单独的平台，配合Webpack可以很好的发挥它们的作用。接下来介绍Webpack中另一个非常重要的功能-Plugins\r\n\r\n插件（Plugins）\r\n\r\n插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。\r\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\r\n\r\nWebpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。\r\n\r\n使用插件的方法\r\n\r\n要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续看例子，我们添加了一个实现版权声明的插件。\r\n\r\n//webpack.config.js\r\nvar webpack = require(\'webpack\');\r\n\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {...},\r\n\r\n  module: {\r\n    loaders: [\r\n      { test: /\\.json$/, loader: &quot;json&quot; },\r\n      { test: /\\.js$/, exclude: /node_modules/, loader: \'babel\' },\r\n      { test: /\\.css$/, loader: \'style!css?modules!postcss\' }//这里添加PostCSS\r\n    ]\r\n  },\r\n  postcss: [\r\n    require(\'autoprefixer\')\r\n  ],\r\n\r\n  plugins: [\r\n    new webpack.BannerPlugin(&quot;Copyright Flying Unicorns inc.&quot;)//在这个数组中new一个就可以了\r\n  ],\r\n\r\n  devServer: {...}\r\n}\r\n通过这个插件，打包后的JS文件显示如下\r\n\r\n\r\nbundled JavaScript file\r\n\r\n知道Webpack中的插件如何使用了，下面给大家推荐几个常用的插件\r\n\r\nHtmlWebpackPlugin\r\n\r\n这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。\r\n\r\n安装\r\n\r\nnpm install --save-dev html-webpack-plugin\r\n这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些改变：\r\n\r\n移除public文件夹，利用此插件，HTML5文件会自动生成，此外CSS已经通过前面的操作打包到JS中了，public文件夹里。\r\n在app目录下，创建一个Html文件模板，这个模板包含title等其它你需要的元素，在编译过程中，本插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，在本例中我们命名模板文件名称为index.tmpl.html，模板源代码如下\r\n&lt;!DOCTYPE html&gt;\r\n&lt;html lang=&quot;en&quot;&gt;\r\n  &lt;head&gt;\r\n    &lt;meta charset=&quot;utf-8&quot;&gt;\r\n    &lt;title&gt;Webpack Sample Project&lt;/title&gt;\r\n  &lt;/head&gt;\r\n  &lt;body&gt;\r\n    &lt;div id=\'root\'&gt;\r\n    &lt;/div&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;\r\n3.更新webpack的配置文件，方法同上,新建一个build文件夹用来存放最终的输出文件\r\n\r\nvar webpack = require(\'webpack\');\r\nvar HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n\r\n  entry:  __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/build&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      { test: /\\.json$/, loader: &quot;json&quot; },\r\n      { test: /\\.js$/, exclude: /node_modules/, loader: \'babel\' },\r\n      { test: /\\.css$/, loader: \'style!css?modules!postcss\' }\r\n    ]\r\n  },\r\n  postcss: [\r\n    require(\'autoprefixer\')\r\n  ],\r\n\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: __dirname + &quot;/app/index.tmpl.html&quot;//new 一个这个插件的实例，并传入相关的参数\r\n    })\r\n  ],\r\n\r\n  devServer: {\r\n    colors: true,\r\n    historyApiFallback: true,\r\n    inline: true\r\n  }\r\n}\r\nHot Module Replacement\r\n\r\nHot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。\r\n在webpack中实现HMR也很简单，只需要做两项配置\r\n\r\n在webpack配置文件中添加HMR插件；\r\n在Webpack Dev Server中添加“hot”参数；\r\n不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。\r\n\r\n整理下我们的思路，具体实现方法如下\r\n\r\nBabel和webpack是独立的工具\r\n二者可以一起工作\r\n二者都可以通过插件拓展功能\r\nHMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；\r\nBabel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作；\r\n更新我们的例子来实际看看如何配置\r\n\r\n//webpack中的配置\r\nvar webpack = require(\'webpack\');\r\nvar HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  devtool: \'eval-source-map\',\r\n  entry: __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/build&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      { test: /\\.json$/, loader: &quot;json&quot; },\r\n      { test: /\\.js$/, exclude: /node_modules/, loader: \'babel\' },\r\n      { test: /\\.css$/, loader: \'style!css?modules!postcss\' }\r\n    ]\r\n  },\r\n  postcss: [\r\n    require(\'autoprefixer\')\r\n  ],\r\n\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: __dirname + &quot;/app/index.tmpl.html&quot;\r\n    }),\r\n    new webpack.HotModuleReplacementPlugin()//热加载插件\r\n  ],\r\n\r\n  devServer: {\r\n    colors: true,\r\n    historyApiFallback: true,\r\n    inline: true,\r\n    hot: true\r\n  }\r\n}\r\n安装react-transform-hmr\r\n\r\nnpm install --save-dev babel-plugin-react-transform react-transform-hmr\r\n配置Babel\r\n\r\n{\r\n  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;],\r\n  &quot;env&quot;: {\r\n    &quot;development&quot;: {\r\n    &quot;plugins&quot;: [[&quot;react-transform&quot;, {\r\n       &quot;transforms&quot;: [{\r\n         &quot;transform&quot;: &quot;react-transform-hmr&quot;,\r\n\r\n         &quot;imports&quot;: [&quot;react&quot;],\r\n\r\n         &quot;locals&quot;: [&quot;module&quot;]\r\n       }]\r\n     }]]\r\n    }\r\n  }\r\n}\r\n现在当你使用React时，可以热加载模块了\r\n\r\n产品阶段的构建\r\n\r\n目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。\r\n\r\n对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个“webpack.production.config.js”的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下\r\n\r\nvar webpack = require(\'webpack\');\r\nvar HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  entry: __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/build&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        loader: \'style!css?modules!postcss\'\r\n      }\r\n    ]\r\n  },\r\n  postcss: [\r\n    require(\'autoprefixer\')\r\n  ],\r\n\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: __dirname + &quot;/app/index.tmpl.html&quot;\r\n    }),\r\n  ],\r\n\r\n}\r\n//package.json\r\n{\r\n  &quot;name&quot;: &quot;webpack-sample-project&quot;,\r\n  &quot;version&quot;: &quot;1.0.0&quot;,\r\n  &quot;description&quot;: &quot;Sample webpack project&quot;,\r\n  &quot;scripts&quot;: {\r\n    &quot;start&quot;: &quot;webpack-dev-server --progress&quot;,\r\n    &quot;build&quot;: &quot;NODE_ENV=production webpack --config ./webpack.production.config.js --progress&quot;\r\n  },\r\n  &quot;author&quot;: &quot;Cássio Zen&quot;,\r\n  &quot;license&quot;: &quot;ISC&quot;,\r\n  &quot;devDependencies&quot;: {...},\r\n  &quot;dependencies&quot;: {...}\r\n}\r\n优化插件\r\n\r\nwebpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能\r\n\r\nOccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID\r\nUglifyJsPlugin：压缩JS代码；\r\nExtractTextPlugin：分离CSS和JS文件\r\n我们继续用例子来看看如何添加它们，OccurenceOrder 和 UglifyJS plugins 都是内置插件，你需要做的只是安装它们\r\n\r\nnpm install --save-dev extract-text-webpack-plugin\r\n在配置文件的plugins后引用它们\r\n\r\nvar webpack = require(\'webpack\');\r\nvar HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\nvar ExtractTextPlugin = require(\'extract-text-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  entry: __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/build&quot;,\r\n    filename: &quot;bundle.js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        loader: ExtractTextPlugin.extract(\'style\', \'css?modules!postcss\')\r\n      }\r\n    ]\r\n  },\r\n  postcss: [\r\n    require(\'autoprefixer\')\r\n  ],\r\n\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: __dirname + &quot;/app/index.tmpl.html&quot;\r\n    }),\r\n    new webpack.optimize.OccurenceOrderPlugin(),\r\n    new webpack.optimize.UglifyJsPlugin(),\r\n    new ExtractTextPlugin(&quot;style.css&quot;)\r\n  ]\r\n}\r\n缓存\r\n\r\n缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）\r\n\r\nwebpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前\r\n\r\nvar webpack = require(\'webpack\');\r\nvar HtmlWebpackPlugin = require(\'html-webpack-plugin\');\r\nvar ExtractTextPlugin = require(\'extract-text-webpack-plugin\');\r\n\r\nmodule.exports = {\r\n  entry: __dirname + &quot;/app/main.js&quot;,\r\n  output: {\r\n    path: __dirname + &quot;/build&quot;,\r\n    filename: &quot;[name]-[hash].js&quot;\r\n  },\r\n\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.json$/,\r\n        loader: &quot;json&quot;\r\n      },\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: \'babel\'\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        loader: ExtractTextPlugin.extract(\'style\', \'css?modules!postcss\')\r\n      }\r\n    ]\r\n  },\r\n  postcss: [\r\n    require(\'autoprefixer\')\r\n  ],\r\n\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      template: __dirname + &quot;/app/index.tmpl.html&quot;\r\n    }),\r\n    new webpack.optimize.OccurenceOrderPlugin(),\r\n    new webpack.optimize.UglifyJsPlugin(),\r\n    new ExtractTextPlugin(&quot;[name]-[hash].css&quot;)\r\n  ]\r\n}\r\n现在用户会有合理的缓存了。\r\n\r\n总结\r\n\r\n这是一篇好长的文章，谢谢你的耐心，能仔细看到了这里，大概半个月前我第一次自己一步步配置项目所需的Webpack后就一直想写一篇笔记做总结，几次动笔都不能让自己满意，总觉得写不清楚。直到看到本文的英文版Webpack for React，真的有多次豁然开朗的感觉，喜欢看原文的点链接就可以看了。其实关于Webpack本文讲述得仍不完全，不过相信你看完后已经进入Webpack的大门，能够更好的探索其它的关于Webpack的知识了。\r\n', '45', '2017-07-15');
INSERT INTO `te_article` VALUES ('46', '前端面试笔试常见问题汇总', '本节主要讲解面试过程中的常见问题，部分来源于网上的收集，部分原创。\r\n一、html 和 css 部分\r\n1.常见的块状元素和行内元素？\r\n 答：块状元素（div p h1 h2 h3 h4 form ul），行内元素（a b br i span input select）\r\n2.css引入的方式有哪些? link和@import的区别是?\r\n 内联 内嵌 外链 导入 区别 ：同时加载 前者无兼容性，后者CSS2.1以下浏览器不支持 Link 支持使用javascript改变样式，后者不可\r\n3.css选择符的优先级别？\r\n 答：行内&gt;id&gt;class&gt;直接选中&gt;通配符*&gt;间接选中\r\n4.浏览器内核？\r\n 答：\r\n–IE: trident内核\r\n–Firefox：gecko内核\r\n–Safari：webkit内核\r\n–Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核\r\n–Chrome：Blink(基于webkit，Google与Opera Software共同开发)\r\n5.超链接四个状态书写的正确顺序是？\r\n 答：link visited hover active\r\n6.标签上title与alt属性的区别是什么？\r\n 答：Alt 当图片不显示时替代显示的文字，Title 为该属性提供信息当鼠标移到图片上面是显示的文字\r\n7.描述css reset的作用及常用的解决方案？\r\n 答：（1）作用，reset重置浏览器因品种不同、版本不同产生的的css默认属性区别 （2）解决方法，手动重置、引入normalize.css或引入respond.js文件等；\r\n 表示几层含义？\r\n 答：（1）当前文件为html5文件 （2）当前文件遵循浏览器标准模式，不会按照不同浏览器私有标准执行\r\n8.浏览器标准模式和怪异模式之间的区别是什么?\r\n 答：盒子模型的渲染模式的不同，使用 window.top.document.compatMode 可显示为什么模式\r\n9.如何对网站的文件和资源进行优化?\r\n 答：文件合并（如精灵图）、文件最小化/文件压缩、使用CDN托管、使用缓存\r\n10.清除浮动最好的一种方法？\r\n 答：\r\n .clearfix:before,.clearfix:after{content:&quot;&quot;; display:table;} \r\n.clearfix:after{clear:both;} \r\n.clearfix{*zoom:1;/*IE/7/6*/}\r\n11.引入外部字体的方法？\r\n 答：\r\n  @font-face{\r\n\r\nfont-family:\'YourWebFontName\';\r\n\r\nsrc:url(\'YourWebFontName.eot\'); /\\* IE9 Compat Modes \\*/\r\n\r\nsrc:url(\'YourWebFontName.eot?#iefix\') format(\'embedded-opentype\'), /\\* IE6-IE8 \\*/\r\n\r\n         url(\'YourWebFontName.woff\') format(\'woff\'), /\\* Modern Browsers \\*/\r\n\r\n         url(\'YourWebFontName.ttf\')  format(\'truetype\'), /\\* Safari, Android, iOS \\*/\r\n\r\n         url(\'YourWebFontName.svg#YourWebFontName\') format(\'svg\'); /\\* Legacy iOS \\*/\r\n}\r\n12.简述一下src与href的区别\r\n 答：href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。src 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。\r\n13.什么是CSS Hack？\r\n 答：\r\n     // 1、条件Hack\r\n   &lt;!--[if IE]&gt;\r\n      &lt;style&gt;\r\n            .test{color:red;}\r\n      &lt;/style&gt;\r\n   &lt;![endif]--&gt;\r\n   // 2、属性Hack\r\n    .test{\r\n    color:#090\\9; /* For IE8+ */\r\n    *color:#f00;  /* For IE7 and earlier */\r\n    _color:#ff0;  /* For IE6 and earlier */\r\n    }\r\n   // 3、选择符Hack\r\n    * html .test{color:#090;}       /* For IE6 and earlier */\r\n    * + html .test{color:#ff0;}     /* For IE7 */\r\n14.什么叫优雅降级和渐进增强？\r\n 答：\r\n–渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\r\n–优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\r\n–区别：\r\na.优雅降级是从复杂的现状开始，并试图减少用户体验的供给\r\nb.渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要\r\nc.降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带\r\n二、javascript 部分\r\n1.javascript的typeof返回哪些数据类型？\r\n 答：Object number function boolean underfind\r\n2.split() join() 的区别？\r\n 答：前者是切割成数组的形式，后者是将数组转换成字符串\r\n3.例举3种强制类型转换和2种隐式类型转换\r\n 答：强制（parseInt,parseFloat,number）、隐式（== – ===）\r\n4.数组方法pop() push() unshift() shift()\r\n 答：push()尾部添加 pop()尾部删除 unshift()头部添加 shift()头部删除\r\n5.IE和标准下有哪些兼容性的写法\r\n 答：（1）var ev = ev || window.event （2）var target = ev.srcElement||ev.target （3）document.documentElement.clientWidth || document.body.clientWidth\r\n6.js 事件绑定的兼容性写法\r\n 答：\r\n &lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n&lt;meta charset=&quot;utf-8&quot;&gt;\r\n&lt;title&gt;无标题文档&lt;/title&gt;\r\n&lt;script&gt;\r\nfunction myAddEvent(obj, ev, fn)\r\n{\r\n        // ie\r\n    if(obj.attachEvent)\r\n    {\r\n        obj.attachEvent(\'on\'+ev, fn);\r\n    }\r\n    else\r\n    {\r\n        obj.addEventListener(ev, fn, false);\r\n    }\r\n}\r\n\r\nwindow.onload=function ()\r\n{\r\n    var oBtn=document.getElementById(\'btn1\');\r\n\r\n    myAddEvent(oBtn, \'click\', function (){\r\n        alert(\'a\');\r\n    });\r\n\r\n    myAddEvent(oBtn, \'click\', function (){\r\n        alert(\'b\');\r\n    });\r\n};\r\n&lt;/script&gt;\r\n&lt;/head&gt;\r\n\r\n&lt;body&gt;\r\n&lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n7.window.onload 和 document.onready 的区别？\r\n 答：前者是事件，一个页面如果出现多个只有最后一个有作用。后者出现多个，会按顺序逐一执行。前者是在结构和样式加载完才执行js，后者是在结构加载完就执行js。\r\n8.事件绑定和普通事件的区别？\r\n 答：对同一个对象执行多个同样的事件，事件绑定可以多次执行，普通事件只会执行最后一个。\r\n9.ajax请求的时候get和post方式的区别？\r\n 答：post数据量大更安全，get数据量小不太安全但是方便\r\n10.事件委托\r\n 答：利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行。如下面的列子。\r\n &lt;ul id=&quot;ul1&quot;&gt;\r\n    &lt;li&gt;111&lt;/li&gt;\r\n    &lt;li&gt;222&lt;/li&gt;\r\n    &lt;li&gt;333&lt;/li&gt;\r\n    &lt;li&gt;444&lt;/li&gt;\r\n&lt;/ul&gt;\r\n\r\nwindow.onload = function(){\r\n　　var oUl = document.getElementById(&quot;ul1&quot;);\r\n　　oUl.onclick = function(ev){\r\n　　　　var ev = ev || window.event;\r\n　　　　var target = ev.target || ev.srcElement;\r\n　　　　if(target.nodeName.toLowerCase() == \'li\'){\r\n　 　　　　　　 alert(123);\r\n　　　　　　　  alert(target.innerHTML);\r\n　　　　}\r\n　　}\r\n}\r\n11.闭包\r\n 答：读取其他函数（函数a）内部变量的函数（函数b），理论上是不可能的，只有当函数b也在函数a内部时候才可以实现。具体如下面的例子。\r\n 　　function a(){\r\n　　　　var n=999;\r\n\r\n　　　　function b(){\r\n　　　　　　alert(n); // 999\r\n　　　　}\r\n　　}\r\n12.解释jsonp的原理，以及为什么不是真正的ajax\r\n 答：动态创建script标签，回调函数。ajax是页面无刷新请求数据操作。\r\n13.javascript的本地对象，内置对象和宿主对象？\r\n 答：本地对象为array obj regexp等可以new实例化，内置对象为gload Math 等不可以实例化的，宿主为浏览器自带的document,window 等。\r\n14.== 和 === 的不同？\r\n 答：前者会自动转换类型，后者不会。前者只判断值是否相等，后者要判断值和数据类型是否一致。\r\n15.javascript的同源策略？\r\n 答：同源，要求 协议、主机名和端口号 都一致，如 http://主机名:8080\r\n16.数组去重的一种方法\r\n 答：\r\n function oSort(arr)\r\n{\r\n    var result ={};\r\n    var newArr=[];\r\n    for(var i=0;i&lt;arr.length;i++)\r\n    {\r\n        if(!result[arr])\r\n        {\r\n            newArr.push(arr);\r\n            result[arr]=1;\r\n        }\r\n    }\r\n    return newArr;\r\n}\r\n17.Javascript中callee和caller的作用？\r\n 答：\r\n–caller是返回一个对函数的引用，该函数调用了当前函数；\r\n–callee是返回正在被执行的function函数，也就是所指定的function对象的正文。\r\n18.请描述一下cookies，sessionStorage和localStorage的区别\r\n 答：\r\n–sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。\r\n–web storage和cookie的区别\r\n–Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。\r\n–除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。\r\n19.跨域请求资源的方法有哪些？\r\n 答：详见 http://www.cnblogs.com/2050/p/3191744.html\r\n–通过jsonp跨域\r\n–通过修改document.domain来跨子域\r\n–使用window.name来进行跨域\r\n–使用HTML5中新引进的window.postMessage方法来跨域传送数据\r\n20.谈谈垃圾回收机制方式及内存管理\r\n 答：\r\n–JavaScript具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。\r\n–js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。\r\n–js内存泄露，一般都是发生在ie中。但是现在ie较高的版本已经不存在这类问题。\r\n–最简单的方法，记住这几个就行\r\n•循环要严谨，不能出现死循环\r\n•定时器开启后，要关闭\r\n•变量（包含对象）使用完后，系统会自动清除，不用手动清除\r\n•事件绑定后，要解除，如 attachEvement 和 remove... ，jq的on off等\r\n21.简述同步和异步的区别？\r\n 答：同步是阻塞模式，异步是非阻塞模式。\r\n–（1）同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；\r\n–（2）异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。\r\n三、http 部分\r\n1.一次完整的HTTP事务是怎样的一个过程?\r\n 答：a. 域名解析，b. 发起TCP的3次握手，c. 建立TCP连接后发起http请求，d. 服务器端响应http请求，浏览器得到html代码，e. 浏览器解析html代码，并请求html代码中的资源，f. 浏览器对页面进行渲染呈现给用户\r\n2.HTTP的状态码有哪些？\r\n 答：参考这里 http://www.runoob.com/http/http-status-codes.html ，主要记住这几个\r\n–200 OK 请求成功。一般用于GET与POST请求\r\n–301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\r\n–403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求\r\n–404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面\r\n–500 Internal Server Error 服务器内部错误，无法完成请求\r\n–502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求\r\n3.HTTPS是如何实现加密\r\n 答：https是在http的基础上多了一次协议ssl，该协议用来给传输的内容进行加密。\r\n四、部分编程算法题\r\n1.统计字符串中字母个数或统计最多字母数。\r\nvar str = &quot;aaaabbbccccddfgh&quot;;\r\nvar obj  = {};\r\nfor(var i=0;i&lt;str.length;i++){\r\n    var v = str.charAt(i);\r\n    if(obj[v] &amp;&amp; obj[v].value == v){\r\n        obj[v].count = ++ obj[v].count;\r\n    }else{\r\n        obj[v] = {};\r\n        obj[v].count = 1;\r\n        obj[v].value = v;\r\n    }\r\n}\r\nfor(key in obj){\r\n    document.write(obj[key].value +\'=\'+obj[key].count+\'&amp;nbsp;\'); \r\n    // a=4  b=3  c=4  d=2  f=1  g=1  h=1 \r\n}   \r\n2.数组快速排序\r\n var quickSort = function(arr) {\r\n　　if (arr.length &lt;= 1) { return arr; }\r\n　　var pivotIndex = Math.floor(arr.length / 2);\r\n　　var pivot = arr.splice(pivotIndex, 1)[0];\r\n　　var left = [];\r\n　　var right = [];\r\n　　for (var i = 0; i &lt; arr.length; i++){\r\n　　　　if (arr[i] &lt; pivot) {\r\n　　　　　　left.push(arr[i]);\r\n　　　　} else {\r\n　　　　　　right.push(arr[i]);\r\n　　　　}\r\n　　}\r\n　　return quickSort(left).concat([pivot], quickSort(right));\r\n};\r\n3.二分法查找\r\n二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。\r\n     // 非递归算法\r\n        function binary_search(arr, key) {\r\n            var low = 0,\r\n                high = arr.length - 1;\r\n            while(low &lt;= high){\r\n                var mid = parseInt((high + low) / 2);\r\n                if(key == arr[mid]){\r\n                    return  mid;\r\n                }else if(key &gt; arr[mid]){\r\n                    low = mid + 1;\r\n                }else if(key &lt; arr[mid]){\r\n                    high = mid -1;\r\n                }else{\r\n                    return -1;\r\n                }\r\n            }\r\n        };\r\n        var arr = [1,2,3,4,5,6,7,8,9,10,11,23,44,86];\r\n        var result = binary_search(arr,10);\r\n        alert(result); // 9 返回目标元素的索引值    \r\n    // 递归算法\r\n        function binary_search(arr,low, high, key) {\r\n            if (low &gt; high){\r\n                return -1;\r\n            }\r\n            var mid = parseInt((high + low) / 2);\r\n            if(arr[mid] == key){\r\n                return mid;\r\n            }else if (arr[mid] &gt; key){\r\n                high = mid - 1;\r\n                return binary_search(arr, low, high, key);\r\n            }else if (arr[mid] &lt; key){\r\n                low = mid + 1;\r\n                return binary_search(arr, low, high, key);\r\n            }\r\n        };\r\n        var arr = [1,2,3,4,5,6,7,8,9,10,11,23,44,86];\r\n        var result = binary_search(arr, 0, 13, 10);\r\n        alert(result); // 9 返回目标元素的索引值  \r\n4.清除字符串前后的空格\r\nfunction trim(str) {\r\n    if (str &amp;&amp; typeof str === &quot;string&quot;) {\r\n        return str.replace(/(^\\s*)|(\\s*)$/g,&quot;&quot;); //去除前后空白符\r\n    }\r\n}\r\n5.验证邮箱\r\nvar reg = /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w{2,3}){1,3})$/;\r\nvar email = &quot;example@qq.com&quot;;\r\nconsole.log(reg.test(email));\r\n五、web 安全问题\r\n1.你所了解到的Web攻击技术\r\n•（1）XSS（Cross-Site Scripting，跨站脚本攻击）：指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者JavaScript进行的一种攻击。\r\n•（2）SQL注入攻击\r\n•（3）CSRF（Cross-Site Request Forgeries，跨站点请求伪造）：指攻击者通过设置好的陷阱，强制对已完成的认证用户进行非预期的个人信息或设定信息等某些状态更新。\r\n六、补充知识\r\n1.浏览器是如何渲染页面的\r\n–（1）解析HTML文件，创建DOM树\r\n•自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。\r\n–（2）解析CSS\r\n•优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式；\r\n•特定级：id数100+类或伪类数10+tag名称*1\r\n–（3）将CSS与DOM合并，构建渲染树（renderingtree）\r\n•DOM树与HTML一一对应，渲染树会忽略诸如head、display:none的元素\r\n–（4）布局和绘制，重绘（repaint）和重排（reflow）\r\n•重排：若渲染树的一部分更新，且尺寸变化，就会发生重排；\r\n•重绘：部分节点需要更新，但不改变其他集合形状。如改变某个元素的颜色，就会发生重绘。\r\n2.重绘和重排何时会发生，如何避免？\r\n–发生下面这些情况：\r\n （1）增加或删除DOM节点；\r\n （2）display:none（重排并重绘）；visibility:hidden（重排）；\r\n （3）移动页面中的元素；\r\n （4）增加或修改样式；\r\n （5）用户改变窗口大小，滚动页面等。\r\n–如何避免\r\n （1）不要一个个修改属性，应通过一个class来修改\r\n （2）clone节点，在副本中修改，然后直接替换当前的节点；\r\n （3）若要频繁获取计算后的样式，请暂存起来；\r\n （4）降低受影响的节点：在页面顶部插入节点将影响后续所有节点。而绝对定位的元素改变会影响较少的元素；\r\n （5）批量添加DOM：多个DOM插入或修改，应组成一个长的字符串后一次性放入DOM。使用innerHTML永远比DOM操作快。（特别注意：innerHTML不会执行字符串中的嵌入脚本，因此不会产生XSS漏洞）。\r\n3.版本号理解 V1.12.1.20170908_beta 各个数字代表什么\r\n 答：1.12.1.20170908_beta 主版本号.副版本号.修订版本号.日期版本号_希腊字母版本号\r\n4.多个页面之间如何进行通信\r\n 答：使用cookie，使用web worker，使用localeStorage和sessionStorage\r\n七、其他\r\n•腾讯： https://zhuanlan.zhihu.com/p/22606894\r\n•https://www.zhihu.com/question/26814439/answer/109607719\r\n•github上的总集： https://github.com/BearD01001/front-end-QA-to-interview\r\n•补充算法题： http://www.codeceo.com/article/the-common-algorithmic-problems-in-front-end-interviews.html\r\n•大公司面试汇总： http://www.cnblogs.com/xxcanghai/p/5205998.html\r\n•es6学习： http://es6.ruanyifeng.com/', '45', '2017-07-15');

-- ----------------------------
-- Table structure for te_comment
-- ----------------------------
DROP TABLE IF EXISTS `te_comment`;
CREATE TABLE `te_comment` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `a_id` int(11) NOT NULL,
  `content` text NOT NULL COMMENT '评论内容',
  `create_time` date NOT NULL COMMENT '评论时间',
  `comauthor` varchar(32) NOT NULL COMMENT '评论人',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of te_comment
-- ----------------------------
INSERT INTO `te_comment` VALUES ('11', '14', '受益匪浅啊\r\n', '2017-05-25', 'root');
INSERT INTO `te_comment` VALUES ('12', '13', '好东西，不错哦！', '2017-05-25', 'wrp');
INSERT INTO `te_comment` VALUES ('13', '15', '哈哈，不错哈', '2017-07-14', 'root');
INSERT INTO `te_comment` VALUES ('14', '13', '真的学到东西了', '2017-07-14', 'root');
INSERT INTO `te_comment` VALUES ('15', '16', '很美的一篇文章', '2017-07-14', 'root');

-- ----------------------------
-- Table structure for te_contact
-- ----------------------------
DROP TABLE IF EXISTS `te_contact`;
CREATE TABLE `te_contact` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '留言ID',
  `content` text NOT NULL COMMENT '留言内容',
  `create_time` date NOT NULL COMMENT '留言时间',
  `f_id` int(10) NOT NULL COMMENT '外键ID',
  `lyauthor` varchar(32) NOT NULL COMMENT '留言者',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of te_contact
-- ----------------------------
INSERT INTO `te_contact` VALUES ('19', '为什么PHP是世界上最好的语言', '2017-05-25', '45', 'root');
INSERT INTO `te_contact` VALUES ('20', '欢迎来到vue的世界！', '2017-05-25', '47', 'wrp');

-- ----------------------------
-- Table structure for te_photo
-- ----------------------------
DROP TABLE IF EXISTS `te_photo`;
CREATE TABLE `te_photo` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '图片ID',
  `url` varchar(32) NOT NULL COMMENT '图片路径',
  `create_time` date NOT NULL COMMENT '上传时间',
  `upauthor` varchar(32) NOT NULL COMMENT '上传者',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of te_photo
-- ----------------------------
INSERT INTO `te_photo` VALUES ('18', '2017-05-25/5926a13912158.jpg', '2017-05-25', 'root');
INSERT INTO `te_photo` VALUES ('19', '2017-05-25/5926a14192dd8.jpg', '2017-05-25', 'root');
INSERT INTO `te_photo` VALUES ('20', '2017-05-25/5926a1492171f.jpg', '2017-05-25', 'root');

-- ----------------------------
-- Table structure for te_user
-- ----------------------------
DROP TABLE IF EXISTS `te_user`;
CREATE TABLE `te_user` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `username` varchar(32) NOT NULL COMMENT '用户名',
  `password` varchar(32) NOT NULL COMMENT '密码',
  `level` int(10) NOT NULL COMMENT '级别',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=49 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of te_user
-- ----------------------------
INSERT INTO `te_user` VALUES ('45', 'root', 'e10adc3949ba59abbe56e057f20f883e', '1');
INSERT INTO `te_user` VALUES ('47', 'wrp', 'e10adc3949ba59abbe56e057f20f883e', '0');
INSERT INTO `te_user` VALUES ('46', 'admin', 'e10adc3949ba59abbe56e057f20f883e', '0');
INSERT INTO `te_user` VALUES ('48', '张三', 'e10adc3949ba59abbe56e057f20f883e', '0');
